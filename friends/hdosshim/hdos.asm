	TITLE	'HDOS SYSTEM DEFINITIONS'

DEBUG	 EQU	 1			DON'T ASSEMBLE FOR DEBUG
***	SYSTEM I/O HANDLER.
*
*	J. G. L., 10/77
*
*	COPYRIGHT HEATH COMPANY.
*
*	G CHANDLER	78/10	Maintenance Release
*			78/04\
*			79/05>	Release	#50.04.00
*			79/06/
*			79/10	Release	#50.05.00
*			80	Release	#50.06.00
*				 /2.0a/ = /80.09.gc/
*				 /2.0b/ = /80.10.gc/
*				 /2.0c/ = /80.11.gc/
*
	SPACE	4,10
***	THE SYSTEM I/O HANDLER HANDLES SYSTEM REQUESTS FOR
*	READS AND WRITES.
*
*	IF A MASS STORAGE DEVICE, THIS DOES THE CORRECT STORAGE
*	MANAGEMENT. IF A SERIAL DEVICE, THE COMMAND IS PASSED
*	ONTO THE DEVICE DRIVER.
	STL	'SYMBOL DEFINITIONS.'
	EJECT

**	MACHINE INSTRUCTIONS

MI.CPI	EQU	376Q
MI.JMP	EQU	303Q
MI.RET	EQU	311Q


**	SYSTEM SYMBOLS
	XTEXT	U8250
	XTEXT	U8251
	XTEXT	H17DEF
	XTEXT	ASCII
	XTEXT	MTR
	XTEXT	HDSROM
	XTEXT	FILDEF
	XTEXT	HOSDEF
	XTEXT	OVLDEF
	XTEXT	DEVDEF
	XTEXT	DIRDEF
	XTEXT	DISDEF
	XTEXT	IOCDEF
	XTEXT	DDDEF
	XTEXT	ECDEF
	XTEXT	DDFDEF
	XTEXT	LABDEF
	XTEXT	PICDEF
	XTEXT	DVDDEF
	XTEXT	DIFDEF
	XTEXT	NAMDEF
	XTEXT	MTRDEF
	XTEXT	FLTDEF
	XTEXT	HOSEQU
	XTEXT	ESVAL
	XTEXT	ESINT
	XTEXT	BOODEF


	
*	CODE	P,SB.ORG		POSITION INDEPENDANT CODE
	CODE	P,SB.ORG+6		Heath ASM includes header	/09.13.GFR/
	CODE	-R			THIS CODE WILL NOT BE RELOCATED
	
	TITLE	'HDOS SYSTEM BOOT CODE'
	STL	'BOOT PROTO'

**	TEMP INITIALIZE

HOSBOOT JMP    HOSBOO1		PERFORM BOOT

*	DEFAULT VALUES FOR SYSTEM

HOSTAB	DS	0		DEFAULT VALUE TABLE
	ERRNZ	*-HOSTAB-FLT.CTY
*		SETUP S.CONTY TO MAP LOWER CASE, ALLOW BKSP, USE 2 STOP BITS.
	DB	CTP.MLO+CTP.MLI+CTP.BKM+CTP.2SB
	ERRNZ	*-HOSTAB-FLT.CWI
	DB	80		S.CONWI
	ERRNZ	*-HOSTAB-FLT.CFC
	DB	4		NUMBER OF FILL CHARACTERS
	ERRNZ	*-HOSTAB-FLT.CRF
	DB	CR		CHARACTER TO BE FILLED
	ERRNZ	*-HOSTAB-FLT.MNC
	DB	6		NUMBER OF CHANNELS
	DB	0		Hold Place
	ERRNZ	*-HOSTAB-FLT.CDB
	DB	CDB.H85		H8-F CONSOLE
	ERRNZ	*-HOSTAB-FLT.CBD
	DW	200000A		BAUD => 2 STOP BITS FOR H8-5
	ERRNZ	*-HOSTAB-FLT.BOP
	DB	0		BOOT OPTION FLAGS
	ERRNZ	*-HOSTAB-FLT.SAL
	DB	0		STAND-ALONE OPTION
	ERRNZ	*-HOSTAB-FLT.PBO
	DB	PBO.DAT		Permanent Boot Options		/80.08.gc/

*	END OF DEFAULT TABLE. START OF BOOT CODE

HOSBOO1 EQU	*
	LXI	SP,STACK	SET UP THE NEW STACK
	IF	DEBUG
	LDA	40077A
	ANA	A
	JNZ	160000A		ENTER DBUG
	ENDIF

*	BOOT CODE

	CALL	SBD		Save Boot Data			/80.08.gc/
	LXI	H,S.TIME
	MVI	B,AIO.CHA-S.TIME
	CALL	$ZERO		ZERO OUT LOTS OF MEMORY
	CALL	SDV		SETUP DEFAULT SYSTEM VALUES
	CALL	RRH		RELOCATE RESIDENT HDOS CODE
	CALL	SRR		SET UP ROM REPLACEMENTS
	CALL	SLR		SET LOW MEMORY REFERENCES
	CALL	SDV		SETUP DEFAULT SYSTEM VALUES
	CALL	SCD		SETUP CONSOLE DRIVER
	CALL	GVM		GIVE VERSION MESSAGE		/80.05.gc/
	CALL	FSM		Fake System Mount		/80.05.gc/
	CALL	LSO		LOCATE SYSTEM OVERLAYS		/80.05.gc/
	CALL	SDT		SETUP DEVICE TABLES		/80.05.gc/
	CALL	SSD		SET SYSTEM DATE			/80.05.gc/
	CALL	MSD		Mount System Diskette		/80.05.gc/
	CALL	UBP		Update Boot Parameters		/80.06.gc/

	LDA	S.BOOTF
	ANI	BOOT.P
	JZ	HOSB2		IGNORE PROLOGUE FILE

	LXI	H,HOSBA
	SCALL	.LINK		TRY TO LINK TO PROLOGUE

HOSB2	MVI	A,1		COULDN'T FINE PROFILE, SO TRY NORMAL
	SCALL	.EXIT
	
HOSBA	DB	'SY'						/80.05.gc/
	DB	'0:PROLOGUE.SYS',0	PROLOGUE FILE		/80.05.gc/
	STL	'SBD	- Save Boot Data'
	EJECT
**	SBD	- Save Boot Data				/80.05.GC/
*
*	SBD saves the data determined at boot time.
*

SBD	LDA	S.CDB
	STA	HOSTAB+FLT.CDB

	LHLD	S.BAUD
	SHLD	HOSTAB+FLT.CBD

	LXI	H,HOSTAB+FLT.CTY
	LDA	S.CONTY
	ANI	CTP.2SB
	ORA	M
	MOV	M,A

	LDA	S.BOOTF
	STA	HOSTAB+FLT.BOP	SAVE THE BOOT FLAGS

	LDA	AIO.UNI
	STA	SUNIT		Save the system unit number
	
	RET
	STL	'RRH - RELOCATE HDOS RESIDENT CODE'
	EJECT
**	RRH - RELOCATE CODE.
*
*	RRH IS CALLED TO RELOCATE THE HOS CODE INTO HIGH MEMORY.
*
*	Modified:	Aug-90
*			 64K RAM System support
*
*	ENTRY	NONE
*	EXIT	(DE) = DISPLACEMENT FACTOR
*	USES	ALL

RRH	EQU	*
	LXI	H,RRH2		START AT RRH2
	MVI	L,0		START AT 256 BOUNDARY
RRH1	INR	H		TRY NEXT BLOCK
	JZ	RRH1.5		Wrap through high memory	/80.08.gc/
	MOV	A,M
	INR	M
	CMP	M
	MOV	M,A		RESTORE
	JNE	RRH1		WAS RAM
RRH1.5	DCX	H		(HL) = HIGHMEM			/80.08.gc/

*	(HL) = HIGHMEM ADDRESS

	IF	DEBUG
RRH2	MVI	A,140A		** DEBUG **
	CMP	H
	JNC	RRH2.5		DONT HAVE OVER 16 K
	LXI	H,140000A	RESTRICT FOR NOW ** DEBUG **
	ELSE
RRH2	EQU	*
	ENDIF
RRH2.5	SHLD	S.HIMEM		SET HARDWARE HIGH MEM
	INX	H		(HL) = LWA+1
	MOV	A,H
	SUI	40Q
	RAR
	RAR
	ANI	77Q		(A) = # OF K
	MOV	E,A
	MVI	D,0
	CALL	$TYPET
	DB	0,'SYSTEM HAS',' '+200Q
	MVI	A,2
	CALL	TDD		TYPE NUMBER OF K
	CALL	$TYPET
	DB	'K OF RAM',200Q
	LDA	S.HIMEM+1	(A) = SIZE
	SUI	24*4+40Q-1	24 K
	JNC	RRH3		ENOUGH ROOM				/2.0a/
	CALL	$TYPET
	DB	BELL,'?01 HDOS REQUIRES AT LEAST 24K!',0,BELL+200Q	/2.0a/
	XRA	A							/2.0a/
	OUT	SC.ACE+UR.IER	Turn off Interrupts			/2.0a/
	OUT	SC.UART+USR						/2.0a/
	JMP	*		Wait for the rapture			/2.0a/

*	HAVE ENOUGH ROOM
	
RRH3	LHLD	S.HIMEM
*	LXI	D,FWASYS-LWASYS-4				/79.11.GC/
	LXI	D,FWASYS-LWASYS+1				/79.11.GC/
	DAD	D		(HL) = NEW FWASYS
	LXI	D,FWAREL
	MOV	A,L
	SUB	E
	MOV	C,A
	MOV	A,H
	SBB	D
	MOV	B,A		(BC) = DISPLACEMENT
	PUSH	B		SAVE
	LXI	B,LWASYS-FWASYS (BC) = SYSTEM RESIDENSE LENGTH
	CALL	$MOVE		MOVE INTO PLACE
	
*	RELOCATE REFERENCEES

	POP	D		(DE) = RELOCATION FACTOR
	LHLD	SB.ORG+PIC.PTR
	LXI	B,SB.ORG
	DAD	B		(HL) = REL TABLE ADDRESS
	
*	RELOCATE CELLS IN BOOT CODE ITSELF

RRH4	PUSH	D		SAVE RELOCATION FACTOR
	MOV	E,M
	INX	H
	MOV	D,M
	INX	H		(DE) = REL ADDRESS OF WORD TO RELOCATE
	MOV	A,D
	ORA	E
	JZ	RRH6		ALL DONE

*	SEE IF ADDRESS IS BEYOND FWAREL

	LXI	B,FWAREL		(BC) = BREAK BETWEEN ABS PRESET AND REL HDOS
	MOV	A,E
	SUB	C
	MOV	A,D
	SBB	B
	JC	RRH5		NOT BEYOND

*	LET REL ROUTINE RELOCATE REST OF CODE

RRH6	LXI	B,-2
	DAD	B		BACKUP (HL)
	POP	B		(BC) = REL FACTOR
	JMP	REL.		RELOCATE AND EXIT

*	(DE) = INDEX OF WORD TO RELOCATE
*	(HL) = RELOCATION TABLE ADDRESS
*	(BC) = CODE DISPLACEMENT FACTOR
*	((SP)) = CODE RELOCATION FACTOR

RRH5	XTHL			(HL) = CODE RELOCATION FACTOR
	LDAX	D
	ADD	L		RELOCATE WORD OF CODE
	STAX	D
	INX	D
	LDAX	D
	ADC	H
	STAX	D		RELOCATE
	XCHG			(DE) = RELOCATION FACTOR
	POP	H		(HL) = RELOCATION TABLE ENTRY ADDRESS
	JMP	RRH4		DO IT AGAIN
	STL	'SRR - SET UP ROM REPLACEMENTS'
	EJECT
**	SRR	-  SET UP ROM REPLACEMENTS			/80.06.gc/
*
*	SET UP RAM REPLACEMENTS FOR THE ROM CODE.
*
*	The H17 specific ROM replacement has been moved to
*	the H17 device driver.
*					G. Chandler, 80.06.19
*

SRR	EQU	*

	RET
	STL	'SLR - SET LOW MEMORY REFERENCES.'
	EJECT
**	SLR - SETUP LOW MEMORY REFERENCES.
*

SLR	EQU	*
	LXI	H,SYSCAL
	SHLD	.UIVEC+18+1	SETUP SYSCALL LINKAGE
	MVI	A,UO.CLK+UO.HLT	DISABLE HALT PROCESSING &
	STA	.MFLAG		REQUEST CLOCK INTERRUPTS

*	SETUP EXIT VECTOR AT 40100A

	CALL	$MOVEL
	DW	SLRAL,SLRA,40100A				/80.06.gc/

*	SETUP LOW-MEMORY STUFF

	MVI	A,4-1		(A) = DEFAULT CLUSTER-1
	STA	S.DCS		SET DEFAULT CLUSTER SIZE

	LXI	H,FWASYS
	SHLD	S.SYSM		SET SYSTEM FWA
	SHLD	S.RFWA		SET RESIDENT CODE FWA
	LXI	H,USERFWA
	SHLD	S.USRM		SET LWA USER MEMORY
	
	XRA	A
	STA	S.CSLMD		CLEAR CONSOLE MODE
	STA	S.CUSOR		CLEAR CURRSOR ADDRESS
	XRA	A
	STA	S.CONFL		CLEAR CONSOLE FLAGS		/80.06.gc/
	
	LXI	H,HIGHDAT
	SHLD	S.DLINK		SET DATA LINK
	LXI	H,OVLTAB
	SHLD	S.OFWA
	LXI	H,CHANTAB
	SHLD	S.CFWA
	LXI	H,DEVLST
	SHLD	S.DFWA

	XRA	A
	STA	S.OVLFL		CLEAR OVL RESIDENCE
	MVI	A,CTP.MLI+CTP.MLO
	STA	S.CONTY		INITIALIZE CONSOLE TYPE

	LXI	H,SECSCR
	SHLD	S.SCR		SET UP OF SYSTEM SCRATCH POINTER

*	SETUP JUMP VECTORS

	MVI	A,MI.JMP
	STA	AIO.VEC
	CALL	$MOVEL
	DW	SLRBL,SLRB,S.JUMPS	SETUP JUMP VECTORS

	XRA	A		System Unit			/80.05.gc/
	STA	AIO.UNI		Set the Boot Unit		/80.05.gc/
	LHLD	SYDD+1						/80.05.gc/
	SHLD	MSYDD		Save current SYDD		/80.05.gc/
	LXI	H,ISY						/80.05.gc/
	SHLD	SYDD+1		Stuff new SYD			/80.05.gc/
	RET

SLRA	DS	0		CODE FOR 40100A
	XRA	A
	STA	SYSMODE
	MVI	A,1		FLAT RESET
	SCALL	.EXIT
SLRAL	EQU	*-SLRA
	ERRPL	SLRAL-9		ONLY ROOM FOR 8 BYTES

SLRB	DS	0		JUMP VECTOR CONTENTS
	ERRNZ	*-SLRB+S.JUMPS-S.SDD
	JMP	SDD
	ERRNZ	*-SLRB+S.JUMPS-S.FASER
	JMP	FATSERR
	ERRNZ	*-SLRB+S.JUMPS-S.DIREA
	JMP	DIREAD
	ERRNZ	*-SLRB+S.JUMPS-S.FCI
	JMP	FCI
	ERRNZ	*-SLRB+S.JUMPS-S.SCI
	JMP	SCI
	ERRNZ	*-SLRB+S.JUMPS-S.GUP
	JMP	GUP
SLRBL	EQU	*-SLRB
	STL	'SDV - SETUP SYSTEM DEFAULT VALUES'
	EJECT
**	SDV - SETUP SYSTEM DEFAULT VALUES.
*
*	SDV SETS UP THE SYSTEM DEFAULT VALUES CONTAINED IN *SHOTAB*,
*	AS DESCRIBED IN *FLTDEF.COM*
*
*	THESE VALUES CAN BE SET IN THE HDOS.SYS BINARY BY THE *SET*
*	UTILITY, AND ARE PROPIGATED INTO THE PROPER SPOTS AT
*	BOOT TIME.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL


SDV	LDA	HOSTAB+FLT.CTY	CONSOLE TYPE FLAGS
	STA	S.CONTY
	LDA	HOSTAB+FLT.CWI	(A) = CONSOLE WIDTH
	STA	S.CONWI
	LDA	HOSTAB+FLT.CFC	(A) = # OF FILL CHARACTERS NEEDED
	STA	CSLDLY		SET PAD DELAY
	LDA	HOSTAB+FLT.CRF
	LHLD	CSLDCA		(HL) = ADDRESS FOR CHARACTER NEEDING PAD
	MOV	M,A		SET CHARACTER			/80.06.gc/
	LDA	HOSTAB+FLT.CDB					/80.06.gc/
	STA	S.CDB		SET CONSOLE DEFINITION BYTE
	LHLD	HOSTAB+FLT.CBD
	SHLD	S.BAUD		SET CONSOLE BAUD RATE
	LDA	HOSTAB+FLT.BOP
	STA	S.BOOTF		SET UP BOOT FLAGS
	LDA	HOSTAB+FLT.SAL
	STA	SALONE		SET UP STAND-ALONE FLAG
	RET
	STL	'SCD - SETUP CONSOLE DRIVER'
	EJECT
**	SCD - SETUP CONSOLE DRIVER.
*
*	SCD SETS UP INTERRUPT VECTORS FOR CONSOLE INPUT, AND
*	SETS UP THE USART

SCD	EQU	*
	IF	DEBUG
	LDA	40077A
	ANA	A
	RNZ			AM IN HBUG
	ENDIF
	LXI	H,SCINI
	SHLD	.UIVEC+7	SETUP VECTOR
	CALL	SCU
	CALL	ECI
	RET
	XTEXT	SCU
	XTEXT	ECI
	STL	'GVM - GIVE VERSION MESSAGE'
	EJECT
**	GVM - GIVE VERSION MESSAGE.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL


GVM	CALL	ECI
	CALL	$TYPTX
	DB	NL,'HDOS Version '
*	DB	VERS/16+'0','.',VERS&00001111B+'0'		/13.09.GFR/
	DB	'2.0'	hard wired due to ASM limitations	/13.09.GFR/
	DB	NL,' Issue # 50.06.00',ENL
	RET
	STL	'FSM	- Fake System Mount'
	EJECT
**	FSM	- Fake System Mount				/80.05.gc/
*
*	FSM reads in just enough of the system paramaters
*	for LSO to locate the overlays.  Then the overlays
*	can really mount the diskettes once the drivers
*	have also been found.
*

	ERRMI	*-LABELE	Label buffer will overlay	/80.05.gc/

FSM	MVI	A,DC.ABT
	CALL	SYDD		ABORT DRIVER

*	Fetch the Label ( and consequently the parameters )

	LXI	B,256
	LXI	D,LABEL
	LXI	H,DDF.LAB
	MVI	A,DC.RER	READ REGARDLESS
	CALL	SYDD
	CC	BOOTERR		BAD ERROR

*	Mount the device so the volume parameters are set-up

	LDA	LABEL+LAB.SER
	MOV	L,A
	MVI	H,0		HL = serial number
	MVI	A,DC.MOU
	CALL	SYDD		Mount the unit
	CC	BOOTERR		Bad error

*	Save the parameters for others to find

	LHLD	LABEL+LAB.GRT
	SHLD	AIO.GRT		GRT address

	LDA	LABEL+LAB.SPG
	SHLD	AIO.SPG		Sectors/Group
	
	MVI	A,1
	STA	S.MOUNT		FLAG SYSTEM MOUNTED
	RET
	STL	'LSO - LOCATE SYSTEM OVERLAY'
	EJECT
**	LSO - LOCATE SYSTEM OVERLAY.
*
*	LSO LOCATES THE SYSTEM OVERLAYS:
*		*HDOSOVL0.SYS*
*		*HDOSOVL1.SYS*
*
*	AND SETS UP POINTERS AND OTHER TABLE DATA TO BOTH.
*
*
*	IT IS READ, AND THE INFO USED TO SETUP THE CELLS
*
*	S.OMAX		SYSTEM OVERLAY MAX
*	S.SSN		SWAP SECTOR NUMBER
*	S.OSN		OVERLAY SECTOR NUMBER
*	S.OVLS		OVERLAY SIZE
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

	ERRMI	*-BUFFE		BUFF will overlay			/80.05.gc/
	
LSO	LXI	D,LSOA
	CALL	LSO.		(HL) = SECTOR NUMBER
	SHLD	S.SSN		SET SWAP NUMBER
	LXI	D,SB.OVMX/256
	DAD	D		(HL) = SECTOR FOR CODE
	SHLD	OVL0*OVL.ENS+OVLTAB+OVL.COD
	CALL	LSO..		(HL) = LENGTH
	SHLD	S.OMAX		SET OVERLAY MAXIMUM SIZE
	SHLD	OVL0*OVL.ENS+OVLTAB+OVL.SIZ

*	SET UP *HDOSOVL2.SYS*

	LXI	D,LSOB
	CALL	LSO.		(HL) = SECTOR NUMBER FOR CODE
	SHLD	OVL1*OVL.ENS+OVLTAB+OVL.COD
	CALL	LSO..		(HL) = LENGTH OF OVERLAY
	SHLD	OVL1*OVL.ENS+OVLTAB+OVL.SIZ
	XCHG
	LHLD	S.OMAX
	CALL	HLCPDE
	RNC			S.OMAX >= SIZE OF THIS OVERLAY
	CALL	$TYPTX
	DB	NL,'?01 Overlay too big',ENL
	JMP	BOOTERR
	
LSO.	PUSH	D		SAVE FILE NAME POINTER
	LXI	B,DIRIDL	(BC) = COUNT
	LXI	H,AIO.DIR+DIR.NAM
	CALL	$MOVE		MOVE IN NAME PATTERN
	LXI	B,DIRIDL	(BC) = MATCH LENGTH
	LHLD	LABEL+LAB.DIS	(HL) = DIRECTORY SECTOR FWA
	CALL	LDE..		LOCATE DIRECTORY ENTRY
	JNC	LSO1		GOTIT

*	MISSING OVERLAY FILE

	CALL	$TYPTX
	DB	NL,'?01 Missing File',' '+200Q
	POP	D		RESTORE FILE NAME POINTER
	LXI	B,DIRIDL	SET UP COUNT
	LXI	H,AIO.DIR+DIR.NAM	SET UP DESTINATION FOR FILE NAME
	CALL	$MOVE		MOVE IN NAME PATTERN
	CALL	$TFN		TYPE FILE NAME
	JMP	BOOTERR		ABORT BOOT

*	FOUND OVERLAY

LSO1	POP	D		DISCARD FILE NAME POINTER SINCE IT IS FOUND
	LXI	D,DIR.FLG
	DAD	D
	MOV	A,M		(A) = FLAG BYTE
	ANI	DIF.CNT
	JZ	LSO2		NOT CONTIGUOUS
	ERRNZ	DIR.FGN-DIR.FLG-2
	INX	H
	INX	H		(HL0 = #DIR.FGN
	MOV	E,M
	MVI	D,0		(DE) = FILE FIRST GROUP NUMBER
	LDA	LABEL+LAB.SPG
	CALL	$MU86		(HL) = SECTOR NUMBER
	RET

*	OVERLAY IS NOT CONTIGUOUS

LSO2	CALL	$TYPTX
	DB      NL,'?01 System Not SYSGENed Properly, or Files Damaged.',ENL
	JMP     BOOTERR
	
LSO..	LXI	B,256
	LXI	D,BUFF
	CALL	$WER		WRITE ENABLE RAM AREA
	CALL	S.READ			READ FROM DISK
	LHLD	BUFF+PIC.LEN
	LXI	B,8
	DAD	B
	RET
	
LSOA	DB	'HDOSOVL0','SYS',0,0	OVERLAY FILE NAME
	ERRNZ	*-LSOA-DIRIDL	LSOA IS ENTIRE SPECIFICATION
LSOB	DB	'HDOSOVL1','SYS',0,0
	ERRNZ	*-LSOB-DIRIDL
	STL	'SDT - SETUP DEVICE TABLE'
	EJECT
**	SDT - SETUP DEVICE TABLE.
*
*	SDT SCANS THE SYSTEM DISK DIRECTORY LOOKING FOR FILES IN
*	THE FORM:
*
*	XX	.DVD
*
*	THESE ENTRYS ARE BUILT INTO THE DEVICE TABLE
*

	ERRMI	BUFF-42200A	Need to write enable buffer	/80.06.gc/
	ERRMI	*-BUFFE		BUFF will overlay		/80.05.gc/
	ERRMI	*-SDTAE		SDT will overlay		/80.05.gc/

SDT	EQU	*
	LHLD	LABEL+LAB.DIS
	SHLD	SDTA+DIS.LNK	SET SECTOR NUMBER TO READ

*	READ NEXT SECTOR
	
SDT1	LHLD	SDTA+DIS.LNK
	MOV	A,H
	ORA	L
	RZ			NO MORE DIRECTORY, AM DONE
	LXI	D,SDTA
	LXI	B,512
	CALL	$WER		WRITE ENABLE RAM
	CALL	S.READ		READ DIRECTORY

*	RUN DOWN THROUGH ENTRYS LOOKING FOR XX.DVD

	LXI	H,SDTA
SDT2	MOV	A,M
	ANA	A
	JZ	SDT1		END OF SECTOR
	ERRNZ	DF.EMP-377Q
	INR	A
	JZ	SDT4		ENTRY IS EMPTY
	ERRNZ	DF.CLR-376Q
	INR	A
	RZ			NO MORE IN DIRECTORY
	PUSH	H
	INX	H
	MOV	A,M
	ANA	A
	JZ	SDT3		IS ONE-CHARACTER NAME
	INX	H
	LXI	D,SDTB
	LXI	B,SDTBL
	CALL	$COMP		COMPARE
	JNE	SDT3		NOT MATCH

*	GOT ONE

	POP	H
	PUSH	H		(HL) = ENTRY FWA
	CALL	EDL		ENTER DRIVER IN LIST

*	TRY ANOTHER ENTRY

SDT3	POP	H		(HL) = ENTRY FWA
SDT4	LDA	SDTA+DIS.ENL
	CALL	$DADA.		ADVANCE
	JMP	SDT2		TRY NEXT

SDTB	DB	0,0,0,0,0,0,'DVD',0,0		REQUIRED EXTENSION
SDTBL	EQU	*-SDTB		LENGTH OF PATTERN
	SPACE	4,10
**	EDL - ENTER DEVICE IN DEVICE LIST.
*
*	EDL ENTERS DEVICE DRIVER INFORMATION INTO THE
*	DEVLST.
*
*	THE FILE IS READ TO SETUP THE DEVICE TABLE ENTRY.
*
*	ENTRY	(HL) = FWA DIRECTORY ENTRY FOR DRIVER
*	EXIT	DRIVER IN DEVLST IF ALL OK
*		DRIVER IGNORED IF PROBLEMS
*	USES	ALL


EDL	MOV	E,M
	INX	H
	MOV	D,M		(DE) = NAME
	XCHG
	SHLD	EDLNAM		SET NAME FIELD IN DEVLST ENTRY
	SHLD	EDLD		SET NAME FOR MESSAGE		/80.05.gc/

*	SETUP SECTOR ADDRESS FOR DRIVER

	LXI	H,DIR.FGN-1
	DAD	D		(HL) = #DIR.FGN
	MOV	A,M		(A) = FIRST GROUP
	STA	EDLDVG		SET DRIVER FIRST GROUP

*	READ FIRST SECTOR OF DRIVER FILE

	MOV	E,A
	MVI	D,0		(DE) = GROUP
	LDA	LABEL+LAB.SPG	A  = Sectors/Group		/80.05.gc/
	CALL	$MU86		(HL) = SECTOR ADDRESS OF 1ST GROUP
	LXI	D,BUFF
	LXI	B,256
	CALL	S.READ		READ IT				/80.06.gc/

*	SEE IF PIC FILE

	LHLD	BUFF
	INR	L
	JNZ	EDL5		NOT BINARY
	MVI	A,FT.PIC
	CMP	H
	JNE	EDL5		NOT PIC

*	SET DEVICE CAPABILITY BYTE

	LDA	BUFF+DVD.DVD	(A) = DRIVER FLAG
	CPI	DVDFLV		SEE IF DRIVER
	JNE	EDL5		NOT DRIVER
	LDA	BUFF+DVD.CAP
	STA	EDLCAP		SET DEVICE CAPABILITY FLAGS
	LDA	BUFF+DVD.MUM
	STA	EDLMUM		SET UP MOUNTED UNITS MASK
	LDA	BUFF+DVD.MNU
	STA	EDLMNU		SET MAXIMUM NUMBER OF UNITS

*	ALLOCATE UNIT DESCRIPTOR TABLES

	LDA	BUFF+DVD.MNU	A  = MAX. NUMBER OF UNITS
	LXI	D,UNT.SIZ
	CALL	$MU86		HL = MEMORY TO ALLOCATE
	CALL	$CHL
	XCHG
	LHLD	S.RFWA
	DAD	D		HL = NEW FWA

	SHLD	S.RFWA
	SHLD	S.SYSM
	SHLD	EDLPTR

*	INITIALIZE THE UNIT DESCRIPTOR TABLE

	LDA	BUFF+DVD.CAP
	MOV	B,A		B  = DEVICE CAPABILITY FLAGS
	LXI	D,BUFF+DVD.UFL
	LDA	BUFF+DVD.MNU

EDL0	DCR	A
	JM	EDL0.5		FINISHED WITH THE UNITS

	PUSH	PSW
	LDAX	D		A  = FLAG VALUE FOR THIS UNIT
	ANA	B		MAP OUT ILLEGAL BITS
	CALL	$INDSB
	DW	UNT.FLG
	PUSH	D
	LXI	D,UNT.SIZ
	DAD	D		HL = NEXT UNIT DESCRIPTOR
	POP	D
	INX	D		MOVE TO NEXT UNIT
	POP	PSW
	JMP	EDL0

EDL0.5	EQU	*

*	SET LENGTH

	LHLD	BUFF+PIC.PTR	(HL) = CODE LENGTH
	LXI	B,-DVD.ENT
	DAD	B		(HL = LEN OF DRIVER CODE
	JNC	EDL5		TOO SMALL
	SHLD	EDLDVL		SET DRIVER LENGTH

*	HAVE BUILT ENTRY FOR DEVLST. INSERT

	LHLD	S.DFWA
	MVI	B,DEVCNT-1	(B) = MAX DRIVER COUNT
	ERRMI	DEVCNT-2		REQUIRE 2
	LXI	D,DEVELEN

EDL1	DAD	D		(HL) = ADDRESS OF NEXT ENTRY
	MOV	A,M
	ORA	A
	ERRNZ	DV.EL		DEVICE END OF LIST FLAG
	JZ	EDL3		GOT ONE
	DCR	B
	JNZ	EDL1		TRY NEXT

*	NO ROOM FOR IT.

	CALL	$TYPTX
	DB	NL,BELL,'?01 Too Many Device Drivers.',' '+200Q
EDL2	LXI	H,EDLB		TYPE NAME
	MVI	A,10
	CALL	$TYPCC		TYPE NAME
	CALL	$TYPTX
	DB	' - Ignored.',ENL
	RET

*	GOT SPOT. PUT IT IN

EDL3	LXI	D,EDLDEV
	LXI	B,DEVELEN
	CALL	$MOVE		COPY INTO TABLE
	MVI	M,0		CLEAR NEXT ENTRY
	RET			RETURN

*	ERROR IN DRIVER FORMAT

EDL5	CALL	$TYPTX
	DB	NL,BELL,'?01 Format Error in Driver File',' '+200Q
	JMP	EDL2
	
EDLB	DB	'SY'		System Device			/80.05.gc/
EDLC	DB	'0:'		Unit Number			/80.05.gc/
EDLD	DB	'XX'		Device Name			/80.05.gc/
	DB	'.DVD',0
	
EDLDEV	EQU	*
	ERRNZ	*-EDLDEV-DEV.NAM
EDLNAM	DB	'  '		DEVICE NAME
	ERRNZ	*-EDLDEV-DEV.RES
	DB	0		NOT RESIDENT
	ERRNZ	*-EDLDEV-DEV.JMP
	DB	303Q		JUMP OPCODE
	ERRNZ	*-EDLDEV-DEV.DDA
	DW	SDD		DRIVER ADDRESS (STAND-IN DEVICE DRIVER)
	ERRNZ	*-EDLDEV-DEV.FLG
EDLCAP	DB	0		FLAGS
	ERRNZ	*-EDLDEV-DEV.MUM
EDLMUM	DB	0		MOUNTED UNIT MASK
	ERRNZ	*-EDLDEV-DEV.MNU
EDLMNU	DB	1		MAXIMUM NUMBER OF UNITS
	ERRNZ	*-EDLDEV-DEV.UNT
EDLPTR	DW	0		UNIT POINTER
	ERRNZ	*-EDLDEV-DEV.DVL
EDLDVL	DW	0		DRIVER LENGTH
	ERRNZ	*-EDLDEV-DEV.DVG
EDLDVG	DB	0		DRIVER SECTOR FIRST GROUP NUMBER
	ERRNZ	*-EDLDEV-DEVELEN
	STL	'MSD	- Mount System Diskette'
	EJECT
**	MSD	- Mount System Diskette				/80.05.gc/
*
*	MSD mounts the system diskette.  It invokes the overlays
*	hence, requires that they already be found via FSM and
*	LSO.
*

MSD	CALL	$CRLF		for aesthetics

*	Find the device table entry for SY:

	LXI	B,'SY'
	LHLD	S.DFWA		HL = address of device table
	
MSD1	MOV	A,M
	ANA	A
	ERRNZ	DV.EL
	JZ	MSD5		At the end of the list without finding SY:
	
	CMP	B
	INX	H
	JNZ	MSD2		Is not SY:
	MOV	A,M
	CMP	C
	JNZ	MSD2		Is not SY:

*	SY: is found

	DCX	H
	SHLD	GSPA		Save pointer to SY: entry
	JMP	MSD3

*	SY is NOT found

MSD2	LXI	D,DEVELEN-1
	DAD	D
	JMP	MSD1		Try the next entry
	
MSD3	CALL	LSD		Load the SYstem Device Driver
	JC	MSD5		Error
	LDA	LABEL+LAB.SER
	MOV	L,A
	MVI	H,0		HL = Volume Number
	MVI	A,DC.MOU
	CALL	SYDD		Set up the volume parameters for read
	JC	MSD5

*	Mount the volume

	LXI	H,MSDA
	SCALL	.MOUNT		Mount the volume

	PUSH	PSW
	CALL	$CRLF		for aesthetics
	POP	PSW
	RNC			No ERROR in mount

*	An error in mount

	CPI	EC.DSC
	JNZ	MSD5
	CALL	$TYPTX
	DB	NL,BELL
	DB	'?01 Disk Structure is Corrupt.',NL
	DB	'Contact Heath Technical Correspondence for Assistance.',ENL
	JMP	BOOTABT

*	Bad ERROR

MSD5	CALL	$TYPTX
	DB	NL,'?01 Unable To Mount System Disk.',ENL
	JMP	BOOTABT

MSDA	DB	'SY'		Device specification
	DB	'0:',0		Unit specification
	SPACE	4,10
**	BOOTERR - ERROR DURING BOOT.
*
BOOTERR CALL	$TYPTX
	DB	NL,BELL,'?01 Disk I/O Error During Boot.',ENL
	ERRNZ	*-BOOTABT
	SPACE	4,10
**	BOOTABT - ABORT BOOT.
*
*

BOOTABT CALL	$TYPTX
	DB	'  Boot Aborted. Will Restart ..','.'+200Q
	JMP	30000A
	STL	'BOOT SUBROUTINES'
	EJECT
**	AGT	- Allocate GRT Table				/80.04.gc/
*
*	AGT allocates enough space for each of the GRT's
*	required by a device driver.
*
*	********
*	* Note *
*	********
*
*		This problem should be addressed more aggresively
*		in that GRT's should not necessarily be on page
*		boudaries, however, this would necessitate replacing
*		much code and sacrificing the efficienty of the
*		allocation algorithem.  For now, we will waste
*		the extra memory, however, at some time this
*		restriction should be removed.
*					G. CHandler 80.04.29
*
*	ENTY:	AIO.DATA initialized
*		DE	= device driver length
*		HL	= DEV.DVG for this device
*
*	EXIT:	HL	= device load address
*		PSW	= 'C' clear if no errors
*			   unit GRT pointers initalized
*			= 'C' set   if not enough room
*
*	USES:	PSW, HL
*

AGT	PUSH	D		save driver length
	CALL	$INDLB
	DW	DEV.FLG-DEV.DVG
	ANI	DT.DD
	STA	AGTA		save directory device flag
	JZ	AGT1		Not a directory device

*	Compute total load length

	CALL	$INDLB
	DW	DEV.MNU-DEV.DVG
	STA	AGTB		save the maximum number of units
	ADD	D		add the tables to the end of the driver
	MOV	D,A

*	Compute load address
AGT1	LHLD	S.SYSM

	MOV	A,L
	SUB	E
	MOV	L,A
	MOV	A,H
	SBB	D
	MOV	H,A		HL = HL - DE

	POP	D
	RC			error
	
	LDA	AGTA
	ANA	A
	RZ			Not a directory device

*	Kludge the load address to force GRT's on page boundaries

	MOV	A,E
	ADD	L
	CMA	A
	PUSH	B
	MVI	B,377Q		sign extend offset !
	MOV	C,A
	DAD	B		Adjust HL to force GRT's on page boundaries
	POP	B
	INX	H

	LDA	AGTB		A  = maximum number of units
	ANA	A
	RZ			No units for some reason?

*	Initialize the unit pointers

	PUSH	D		save load length
	PUSH	H		save load address
	DAD	D
	XCHG			DE = address of first GRT to allocate
	
	PUSH	D
	LHLD	AIO.DTA
	LXI	D,DEV.UNT
	DAD	D		HL = address of UNIT table pointer
	POP	D

AGT2	DCR	A
	JM	AGT3		all finished

	PUSH	PSW
	PUSH	H
	CALL	S.GUP		HL = unit table pointer
	CALL	$INDS
	DW	UNT.GRT		initialize the GRT pointer
	POP	H
	POP	PSW

	INR	D		advance to the next GRT pointer
	JMP	AGT2
	
AGT3	POP	H		restore load address
	POP	D		restore load length
	RET
	
AGTA	DB	0		Directory Device flag
AGTB	DB	0		Maximum Number of Units
	SPACE	4,10
**	LDE - LOCATE DIRECTORY ENTRY.
*
*	LDE LOCATES A DIRECTORY ENTRY CORRESPONDING TO THE AIO.DIR ENTRY.
*
*	ENTRY	(BC) = NUMBER OF CHARACTERS TO MATCH ON
*	EXIT	'C' CLEAR IF FOUND
*		AIO.DES SETUP
*		(HL) = ADDRESS OF DIRECTORY ENTRY IN SECSCR
*		'C' SET IF NOT FOUND
*		(A) = CODE
*	USES	ALL


LDE.	LXI	B,DIRIDL	ENTRY FOR FULL NAME COMPARE

LDE	LHLD	LABEL+LAB.DIS	HL = Directory Sector		/80.05.gc/
	SHLD	AIO.DES						/80.05.gc/

**	ENTRY FOR (HL) = SECTOR NUMBER TO START WITH

LDE..	PUSH	B		SAVE COUNT
	LXI	B,512
	LXI	D,SECSCR
	SHLD	AIO.DES		Assume will find in this block	/80.05.gc/
	CALL	S.READ		READ (know is system device)	/80.05.gc/
	POP	B		RESTORE (BC)

*	SCAN SECTOR FOR INFO

	LXI	H,DIS.ENT+SECSCR

*	COMPARE

LDE3	LXI	D,AIO.DIR+DIR.NAM
	MOV	A,M
	ANA	A
	JM	LDE3.5		NO ENTRY
	PUSH	B		SAVE COPY OF (BC)
	PUSH	H		SAVE ADDRESS
	CALL	$COMP		COMPARE
	POP	H
	POP	B		(BC) = COMPARE COUNT
	RE			GOT MATCH

LDE3.5	LXI	D,DIRELEN	MISSED, SCAN TO NEXT ENTRY
	DAD	D
	MOV	A,M
	ANA	A
	JNZ	LDE3		MORE IN SECTOR

*	DIDNT FIND IT IN THIS SECTOR, TRY NEXT

	LHLD	DIS.LNK+SECSCR
	SHLD	AIO.DES		SET POSSIBLE SECTOR INDEX	/80.05.gc/
	MOV	A,H
	ORA	L
	JNZ	LDE.. 		HAVE MORE SECTORS
	MVI	A,EC.FNF	FILE NOT FOUND
	STC
	RET
	SPACE	4,10
**	LSD	- Load System Device
*
*	LSD loads the system device driver.  Once again, this
*	is somewhat of a kludge since the system device is not
*	mounted yet, but ...
*
*	EXIT:	PSW	= 'C' Clear if NO Error
*			  'C' Set   if    Error
*

LSD	EQU 	*

*	Kludge GRT Pointers for initial load of SY.DVD

	LXI	H,MSDB
	SHLD	LDD8A		Stuff system GRT address
	LDA	LABEL+LAB.SPG
	STA	LDD8B		Stuff system SPG

	LXI	B,256
	LXI	D,MSDB
	LHLD	LABEL+LAB.GRT
	CALL	S.READ		Initialize temporary GRT
	RC

*	Load Driver

	LHLD	GSPA
	SHLD	AIO.DTA
	LXI	D,DEV.RES
	DAD	D
	XCHG			DE = $DEV.RES
	CALL	RDL		Request the driver load
	RC			ERROR

	MVI	A,DC.LOD
	STA	S.DDOPC		Set the OPEN code for the driver call
	CALL	LDD		Load the driver

*	Fix system device driver routine addresses

	CALL	GSP
	CALL	$INDL		DE = system GRT address
	DW	UNT.GRT
	XCHG
	SHLD	LDD8A		Adjust temporary kludget GRT to the real thing

	LHLD	GSPA		HL = SY: device table entry
	CALL	$INDL		DE = driver address
	DW	DEV.DDA
	XCHG
	SHLD	MSYDD		Stuff the Real Driver address
	SHLD	S.RFWA		FOrce as part of HDOS
	XCHG

	LXI	D,ISY
	CALL	$INDS		Stuff mapped address in table
	DW	DEV.DDA
	XCHG

*	Fix device parameters & pointers

	LHLD	GSPA
	CALL	$INDLB		A  = DEV.RES flag
	DW	DEV.RES
	ORI	DR.PR		Flag driver permanently resident
	CALL	$INDSB
	DW	DEV.RES

	ANA	A		CLEAR 'C'
	RET
	SPACE	4,10
**	RDL - REQUEST DEVICE DRIVER.
*
*	RDL SETS A REQUEST FOR THE LOADING OF A DEVICE DRIVER.
*
*	THE DRIVER IS LOADED INTO MEMORY JUST BELOW *S.SYSM*.
*
*	ENTRY	(DE) = $DEV.RES
*	EXIT	'C' SET IF ERROR
*		 (A) = ERROR CODE
*		'C' CLEAR IF OK
*		DEVLST POINTERS SET
*	USES	A,F,B,C,H,L

	
RDL	PUSH	D		SAVE (DE)
	XCHG			(HL) = $DEV.RES
	SHLD	S.DDDTA		SET DEVICE TABLE ADDRESS (OF DEV.RES)
	LXI	D,DEV.DVL-DEV.RES
	DAD	D		(HL) = ADDRESS OF LENGTH
	MOV	E,M
	INX	H
	MOV	D,M		(DE) = LEN OF DRIVER
	ERRNZ	DEV.DVG-DEV.DVL-2
	INX	H

	MOV	A,M		(A) = (DEV.DVG)
	STA	S.DDGRP		SET GROUP FOR FILE

	CALL	AGT		HL = load address		/80.04.gc/

	MVI	A,EC.NRD	NO ROOM FOR DRIVER
	JC	RDL1		ERROR

*	SEE IF THIS IS ABOVE THE USER HIMEM

	XCHG			(DE) = NEW S.SYSM
	SHLD	S.DDLEN		SET LENGTH OF LOAD
	LHLD	S.USRM
	INX	H

	MOV	A,E
	SUB	L
	MOV	A,D
	SBB	H
	MVI	A,EC.NRD
	JC	RDL1		NO ROOM

	XCHG			(HL) = NEW S.SYSM
	SHLD	S.SYSM
	SHLD	S.DDLDA		SET LOAD ADDR

RDL1	POP	D		RESTORE (DE)
	RET
	SPACE	4,10
**	TDD - TYPE DECIMAL DIGITS.
*
*	TDD TYPES A 16 BIT VALUE AS 1 TO 5 DECIMAL DIGITS.
*
*	ENTRY	(D,E) = VALUE
*		(A) = DIGIT COUNT
*	EXIT	VALUE TYPED.
*	USES	A,B,C,F


TDD.	MVI	A,5
TDD	PUSH	H
TDD1	PUSH	PSW
	LXI	H,TDDA-2
	RLC			(A) - DIGIT NUMBER*2
	CALL	$DADA
	MOV	A,M
	INX	H
	MOV	H,M
	MOV	L,A		(HL) = MULTIPLE OF 10
	XCHG			(DE) = DEVISOR, (HL) = VALUE
	MVI	A,377Q
TDD2	DAD	D
	INR	A
	JC	TDD2		IF MORE TO GO
	ADI	'0'
	CALL	$TYPEC.		TYPE DIGIT
	MOV	A,L
	SUB	E
	MOV	E,A		REMOVE EXTRA SUBTRACTION
	MOV	A,H
	SBB	D
	MOV	D,A
	POP	PSW
	DCR	A
	JNZ	TDD1		IF MORE DIGITS
	POP	H
	RET			EXIT

TDDA	EQU	*
	DW	-1
	DW	-10
	DW	-100
	DW	-1000
	DW	-10000
	SPACE	4,10
**	SSD - SET SYSTEM DATE.					/80.08.gc/
*
*	SSD PROMPTS THE USER AS
*
*	DATE (DD-MMM-YY)?
*
*	THE 'DD-MMM-YY' FIELD IS REPLACED BY THE CURRENT
*	SYSTEM DATE, IF A VALID ONE IS IN MEMORY.
*
*	Modified:	If a valid date is not in memory, use
*			the default from the disk being booted.
*								/80.08.gc/
*
*	IN THIS CASE, HITTING 'CR' IN REPLY CAUSES THE CURRENT DATE
*	TO REMAIN.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES ALL
*

SSD	LDA	HOSTAB+FLT.PBO
	ANI	PBO.DAT
	JNZ	SSD0		User Wants the Date

	LXI	H,0
	JMP	SSD8		Stuff the Date
	
SSD0	XRA	A
	STA	SSDA		Flag default legal
	LHLD	S.DATC
	XCHG			DE = Compressed Date
	LXI	H,SSDB		HL = Date FIeld
	MOV	A,D
	ORA	E
	JZ	SSD1		No-Date is Illegal Here
	CALL	$DAD
	JC	SSD1		Illegal Coded Date

*	Compare Decoded date against RAM date

	LXI	B,9
	LXI	D,S.DATE
	LXI	H,SSDB
	CALL	$COMP
	JZ	SSD2		Date field assumed legal

*	Set a new default date

SSD1	LHLD	SB.DAT
	SHLD	S.DATC		Set new default date
	XCHG			DE = Compressed Date
	LXI	H,S.DATE	HL = Date FIeld
	MOV	A,D
	ORA	E
	JZ	SSD1.5		No-Date
	CALL	$DAD
	JNC	SSD2		Legal default date
SSD1.5	MVI	A,1
	STA	SSDA		Set Default Illegal
	
*	Get date from user

SSD2	CALL	$TYPTX
	DB	'Date ','('+200Q
	LDA	SSDA
	ANA	A
	JZ	SSD3		Legal Default Date

	CALL	$TYPTX
	DB	'DD-MMM-Y','Y'+200Q
	JMP	SSD4

SSD3	MVI	A,9
	LXI	H,S.DATE
	CALL	$TYPCC		Type a good date

*	GET REPLY

SSD4	CALL	$TYPTX
	DB	')?',' '+200Q
	LXI	H,SSDB
	CALL	$RTL.		READ TEXT LINE (UPPER CASE)
	JC	SSD2		CTL-D STRUCK
	MOV	A,M
	ANA	A
	JNZ	SSD5		GIVEN REPLY

*	HE DEFAULTED. SEE IF DEFAULT ALLOWED

	LDA	SSDA
	ANA	A
	RZ			DEFAULT OK
	JMP	SSD6		MAKE IT MORE CLEAR WHAT WE WANT

*	CACK DATE

SSD5	CALL	$CAD		CONVERT AUGUSTAN DATE
	JNC	SSD7		DATE GOOD

*	HIS REPLY BAD. TRY AGAIN

SSD6	CALL	$TYPTX
	DB	BELL,' ENTER DATE AS DD-MMM-YY (I.E., 02-JUL-77)',ENL
	JMP	SSD2		TRY AGAIN

*	DATE IS GOOD. SETUP TWO DATE FIELDS FOR SYSTEM

SSD7	XCHG
SSD8	SHLD	S.DATC		SET DATE CODE
	XCHG
	LXI	H,S.DATE
	JMP	$DAD		DECODE DATE INTO ASCII AND RETURN
	
SSDA	DB	0		=0 IFF DEFAULT DATE ALLOWED
	SPACE	4,10
**	UBP	- Update Boot Parameters
*
*	UBP updates the boot parameters by rewriting sector
*	zero.  Since track 0 is written as volume zero, the
*	volume number must be temporarily adjusted.
*
*	ENTRY:	S.DATC	= Current Compressed Date
*
*	EXIT:	None
*
*	USES:	ALL
*

UBP	LDA	SB.VER
	CPI	VERS
	RNZ			Only Update if versions match

	LXI	B,UBPAL
	LXI	D,SB.VER
	LXI	H,UBPA
	CALL	$MOVE		Get the original parameters

	LHLD	S.DATC
	SHLD	UBPA-SB.VER+SB.DAT	Update Date
	LHLD	S.BAUD
	SHLD	UBPA-SB.VER+SB.BAU	Update Baud-Rate

	MVI	C,UBPAL
	LXI	D,SB.VER
	LXI	H,UBPA
	CALL	$COMP
	RZ			No change in parameters

	LXI	B,UBPAL
	LXI	D,UBPA
	LXI	H,SB.VER
	CALL	$MOVE		Move the new data into parameter area

	LXI	H,0
	MVI	A,DC.MOU
	CALL	SYDD		Mount the disk as volume zero
	CC	S.FASER

	LXI	B,256
	LXI	D,SB.BOO
	LXI	H,0
	MVI	A,DC.WRI
	CALL	SYDD		Re-Write the Sector
	JNC	UBP1
	CPI	EC.WP
	JZ	UBP1		Ignore Write-Protect Error

	CALL	S.FASER		Other errors are fatal

UBP1	LDA	LABEL+LAB.SER
	MOV	L,A		L = Volume number
	MVI	H,0
	MVI	A,DC.MOU
	CALL	SYDD		Re-Mount the disk
	CC	S.FASER

	RET

UBPA	DS	SB.BPE-SB.VER	Reserve Space for temporary
UBPAL	EQU	*-UBPA
	XTEXT	CDEHL
	XTEXT	MCU
	XTEXT	MLU
	XTEXT	DTB
	XTEXT	MOVEL
	XTEXT	RCHAR
	XTEXT	MU10
	XTEXT	RTL
	XTEXT	CAD
	XTEXT	DAD
	XTEXT	DU66
	XTEXT	DDD
	XTEXT	UDD
	XTEXT	DADA
	XTEXT	CRLF
	XTEXT	TYPT2
	XTEXT	TYPCH
	XTEXT	TFN
	XTEXT	TYPET
	XTEXT	MU86
	XTEXT	TYPCC
	SPACE	4,10
**	PATCH - PATCH AREA

PATCH	DS	0
	DB	FF,NL,'ANOTHER FINE HEATH SOFTWARE PRODUCT'
	
	ERRMI	64-*+PATCH					/79.06.gc/
	DS	64-*+PATCH					/79.06.gc/
	SPACE	4,10
******************************************************************************
******************************************************************************
**									    **
**	BE VERY CAREFUL ABOUT THE PLACEMENT OF THESE BUFFERS, AND NOTE      **
**	THAT THE  *LABEL*  BUFFER OVERLAYS CODE.  ( MAKE SURE THAT THE      **
**	CODE WHICH IS OVERLAID IS NO LONGER NEEDED AT OVERLAY TIME.)        **
**						G. Chandler		    **
**							79.11.gc	    **
**									    **
**		And even more overlap.			80.05.gc	    **
**									    **
******************************************************************************
******************************************************************************
LABEL	EQU	RRH		256 BYTE BUFFER			/79.11.GC/
LABELE	EQU	LABEL+256					/80.0F.gc/

BUFF	EQU	LABELE		256 BYTE BUFFER			/80.05.gc/
BUFFE	EQU	BUFF+256					/80.05.gc/

SDTA	EQU	S.GRT0		512 BYTE BUFFER			/80.05.gc/
SDTAE	EQU	SDTA+512					/80.05.gc/

SSDB	EQU	BUFF		DATE BUFFER			/79.12.GC/

MSDB	EQU	LABEL+255/256*256	Temporary GRT		/80.06.gc/
OVBUFE	EQU	*		END OF OVERLAID BUFFERS

**	WE MUST MAKE SURE THAT THERE IS ENOUGH MEMORY IN 8K SO THAT
*	THE RESIDENT CODE WILL BE MOVED COMPLETELY ABOVE 'OVBUFE'

	ERRMI	100000A-LENSYS-OVBUFE-20	NOT ENOUGH ROOM FOR EVERYBODY
	STL	'SYSCALL DISPATCH'
	EJECT
***	SYSCALL DISPATCH.
*
*	THE SYSCALL DISPATCH HANDLER IS ENTERED VIA A SYSCALL INSTRUCTION.
*
*	IF THE PROCESSOR IS IN RESIDENT CODE, IT IS CALLED.
*
*	ALL CALLS WHICH INVOKE THE OVERLAY CODE HAVE THEIR STACK POINTER
*	VALUE SAVED. THIS IS A KLUDGE FOR STACK PRESERVATION VIA 'LINK'
*
*	IF THE REQUIRED OVERLAY IS RESIDENT, IT IS CALLED.
*
*	IF THE OVERLAY IS NOT RESIDENT, LOAD IT, RELOCATE IT, AND CALL IT.
*
*	ENTRY	(SP) = RET
*		(RET) = SYSCALL INDEX
*	EXIT	'C' SET IF ILLEGAL CODE
*		 (A) = EC.ILC
*		TO PROCESSOR IF A GOOD LOAD
*		(SP) = PSW
*		(SP+2) = RETURN ADDRESS (ADVANCED PAST CODE)
*	USES	A,F


FWAREL	EQU	*		ABS ADDRESS TO START RELOCATION
	CODE	+R		REMAINING CELLS ARE RELOCATED
FWASYS	EQU	*		SYSTEM FWA

SYSCAL	EQU	*
	STA	S.CACC		SAVE (A)
	XTHL
	MOV	A,M		(A) = CODE
	STA	S.CODE		SET SYSTEM CODE
	INX	H		ADVANCE RETURN ADDRESS
	XTHL

*	Special case calls which may need mass storage device drivers	/2.0b/

	CPI	.MOUNT							/2.0b/
	JZ	SYS0							/2.0b/
	CPI	.MONMS							/2.0b/
	JZ	SYS0							/2.0b/
	CPI	.RESET							/2.0b/
	JNZ	SYS2							/2.0b/							/2.0b/
SYS0	LDA	S.CODE							/2.0b/
	PUSH	PSW						/80.04.GC/
	LDA	S.CACC						/80.04.GC/
	PUSH	PSW						/80.04.GC/
	PUSH	H						/80.04.GC/
	SCALL	.LOADD		preface .MOUNT by .LOADD	/80.04.GC/
	POP	H		restore device descriptor	/80.04.GC/
	JNC	SYS1						/80.04.GC/

*	Discard saved original parameters			/80.04.gc/

	POP	B						/80.04.GC/
	POP	B						/80.04.GC/
	RET			exit with error			/80.04.GC/

*	Restore original parameters				/80.04.gc/

SYS1	POP	PSW						/80.04.GC/
	STA	S.CACC						/80.04.GC/
	POP	PSW						/80.04.GC/
	STA	S.CODE						/80.04.GC/
SYS2	EQU	*

	IF DEBUG
	CPI	.READ		IS CONSOLE FUNCTION
	PUSH	PSW			* * DEBUG * *
	CALL	JGL		CLEAR ACTIVE CHANNEL
	POP	PSW			* * DEBUG * *
	ENDIF

	PUSH	H
	LXI	H,S.OVLFL	STORE S.OVLFL ON STACK WITHOUT
	MOV	H,M		 DAMAGING REGISTERS
	XTHL
SYS3	CALL	SYSCAL0		CALL ALL SYSCALLS TO RETURN HERE

*	ALL SYSCALLS RETURN HERE.
*
*	LOAD ANY POSTPONED DEVICE DRIVERS, AND SEEZ IF A CTL-C OR CTL-Z
*	WAS STRUCK.

	PUSH	PSW
	LDA	SYSMODE
	DCR	A
	JNZ	SYS4		DONT RESTORE USER IF NOT FIRST LEVEL CALL
	LDA	S.OVLFL
	ERRNZ	OVL.UCS-200Q
	ANA	A
	CM	RUC		RESTORE USER CODE, IF SWAPPED

SYS4	POP	PSW
	XTHL			(H) = OLD S.OVLFL
	PUSH	PSW
	MOV	A,H
	ANI	OVL.RES
	JZ	SYS5		WAS NOT PERMANENTLY RESIDENT BEFORE
	MOV	A,H
	ANI	OVL.NUM
	RRC
	RRC
	ERRNZ	OVL.NUM-00001100B
	CALL	LDON		WAS PERM. RESIDENT BEFORE
	CC	FATSERR		OVERLAY WAS TOO BIG

SYS5	LDA	S.DDLDA+1
	ANA	A
	CNZ	LDD		LOAD DEVICE DRIVER IF PENDING
	LXI	H,SYSMODE
	DI			LOCK OUT CONSOLE INTERRUPTS UNTIL *CPA*
	DCR	M		DECREMENT NESTED SYSCAL COUNT
	CZ	$WDR		IF RETURNING TO USER, WRITE DISABLE ROM
	CALL	CPA		CHECK PENDING ABORT
	POP	PSW
	POP	H		RESTORE USER (HL)
	EI
	RET			EXIT


	IF	DEBUG
JGL	PUSH	B
	PUSH	H
	LXI	H,AIO.DDA
	MVI	B,AIO.CHA-AIO.DDA
	CALL	$ZERO
	POP	H
	POP	B
	RET				** DEBUG **
	ENDIF
	SPACE	3,10
SYSCAL0 EQU	*
	PUSH	H		SAVE (HL)
	LXI	H,SYSMODE
	INR	M		COUNT NESTED SYSCALL
	CALL	$WER		WRITE ENABLE RAM AREA
	CPI	.LINK
	JNC	SYSCAL2		IS IN OVERLAY
	CPI	.SYSRES
	JC	SYSCAL1		IS RESIDENT
	MVI	A,EC.ILC
	STC
	POP	H		RESTORE (HL)
	RET			ERROR

*	DISPATCH RESIDENT CALLS

SYSCAL1 LXI	H,SYSCALA
	ADD	A		(A) = CODE*2
	CALL	$DADA.		(HL) = TABLE ADDRESS
	MOV	A,M
	INX	H
	MOV	H,M
	MOV	L,A		(HL) = CODE ADDRESS
	XTHL			PUT ON STACK
	LDA	S.CACC		(A) = (ACC) UPON CALL
	RET			ENTER PROCESSOR CODE

*	DISPATCH OVERLAID CALLS

SYSCAL2 LXI	H,8
	DAD	SP
	SHLD	S.OVSTK		SAVE STACK VALUE
	PUSH	PSW		SAVE CODE

	CPI	.MOUNT
	JNC	SYSCAL3		SECOND OVERLAY REQUIRED
	MVI	A,OVL0		HDOSOVL .SYS
	JMP	SYSCAL4

SYSCAL3 MVI	A,OVL1		HDOSOVL2.SYS

SYSCAL4 CALL	LDON		LOAD INDEXED OVERLAY
	CC	FATSERR		OVERLAY TOO BIG

*	OVERLAY IS NOW LOADED

	CALL	OTI
	DW	OVL.ENT		(HL) = ADDRESS OF ENTRY POINT
	CALL	$HLIHL		(HL) = ENTRY POINT
	PCHL			ENTER CODE
	SPACE	2,10
**	TABLE OF SYSCALL ROUTINES.
*
*	DW	ADDR		ENTRY ADDRESS


SYSCALA DS	0

	DW	EXIT		RETURN TO MONITOR

	DW	SCIN		READ FROM SYSTEM CONSOLE

	DW	SCOUT		WRITE TO SYSTEM CONSOLE

	DW	PRINT		WRITE LINE TO SYSTEM CONSOLE

	DW	READ		READ DATA

	DW	WRITE		WRITE DATA

	DW	CONSL		SET/READ CONSOLE OPTIONS
	DW	CLRCO		CLEAR CONSOLE TYPE AHEAD

	DW	LOADO		LOAD SPECIFIED OVERLAY
	
	DW	VERSN
	EJECT
**	LDON	- LOAD OVERLAY BY NUMBER
*
*	LOAD THE SPECIFIED OVERLAY ACCORDING TO THE NUMBER SPECIFIED.
*	THE NUMBER CORRESPONDS TO THE INDEX IN TABLE SYSCALB,
*	SET THE ENTRY POINT AN D FLAG BYTE IN THE OVERLAY TABLE.
*
*	IF THE OVERLAY IS ALREADY PRESENT, IT IS NOT LOADED.
*
*	IF A SMALLER OVERLAY IS ALREADY LOADED, IT IS TAKEN AS
*	A FATAL SYSTEM ERROR.
*
*	**********************************************************************
*	*								     *
*	*	OVERLAID CALLS TO OTHER OVERLAYS WILL PROBABLY NOT WORK      *
*	*								     *
*	**********************************************************************
*
*
*	ENTRY:	(A)	= INDEX OF OVERLAY TO BE LOADED
*
*	EXIT:	(PSW) 	= 'C' CLEAR IF NO ERROR
*			= 'C' SET   IF    ERROR
*			   (A)  = ERROR CODE
*
*	USES:	(FLAGS)
*

LDON	PUSH	B
	PUSH	D
	PUSH	H

	CPI	OVLMAX		INDEX IS TOO BIG
	JNC	LDON5

*	CHECK TO SEE IF OVERLAY IS PERMANENTLY RESIDENT

	PUSH	PSW		SAVE OVERLAY INDEX
	CALL	OTI
	DW	OVL.FLB		(HL) = ADDRESS OF FLAG BYTE
	MOV	A,M
	ANI	OVL.RES
	JNZ	LDON0		OVERLAY IS PERMANENTLY RESIDENT
	POP	PSW		RESTORE OVERLAY INDEX

*	CHECK TO SEE IF OVERLAY IS PRESENTLY IN MEMORY

	PUSH	PSW		SAVE OVERLAY INDEX
	ADD	A
	ADD	A		A = A*4
	ERRNZ	OVL.NUM-00001100B
	MOV	B,A		(B) = OVERLAY SOUGHT
	LDA	S.OVLFL
	RAR
	JNC	LDON2		NO OVERLAY LOADED
	ERRNZ	OVL.IN-1

*	CHECK TO SEE IF CURRENT OVERLAY IS THE ONE SOUGHT

	RAL
	ANI	OVL.NUM
	CMP	B
	JZ	LDON0		CURRENT == SOUGHT
	LHLD	S.OVLS
	XCHG			(DE) = OLD OVERLAY SIZE
	JMP	LDON3

LDON0	POP	PSW
	ANA	A		CLEAR CARRY
LDON1	POP	H
	POP	D
	POP	B
	RET

*	LOAD THE NEW OVERLAY
LDON2	LXI	D,377377A	LARGE (DE) IF NO PRESENT OVERLAYS
LDON3	LDA	S.MOUNT
	ANA	A
	MVI	A,EC.NOS	NO OPERATING SYSTEM
	JZ	LDON6		NO O.S. 
	MOV	A,B		(A)  = OVERLAY INDEX * 4
	RRC
	RRC			(A)  = OVERLAY INDEX
	CALL	OTI
	DW	OVL.COD		(HL) = ADDRESS OF CODE ENTRY
	PUSH	H
	CALL	$HLIHL
	SHLD	S.OSN		SET NEW OVERLAY SECTOR NUMBER
	POP	H
	INX	H
	INX	H
	ERRNZ	OVL.SIZ-OVL.COD-2
	CALL	$HLIHL
	LDA	S.OVLFL
	ANI	OVL.UCS
	JZ	LDON4		NO USER CODE SWAPPED
	CALL	HLCPDE
	JZ	LDON4		NEW SIZE = PRESENT SIZE
	JC	LDON4		NEW SIZE < PRESENT SIZE
	MVI	A,EC.OTL	NEW SIZE > PRESENT SIZE
	JMP	LDON6

*	SET ENTRY POINT AND FLAG OVERLAY 'IN MEMORY'

LDON4	SHLD	S.OVLS		SET NEW OVERLAY SIZE
	CALL	LDO
	LDA	S.OVLFL
	ANI	377Q-OVL.NUM
	ORA	B
	STA	S.OVLFL		SET OVERLAY NUMBER IN FLAG BYTE
	POP	PSW		RESTORE OVERLAY INDEX
	PUSH	PSW		SAVE OVERLAY INDEX
	CALL	OTI		OVERLAY TABLE INDEXING
	DW	OVL.ENT		(HL) = ADDRESS OF THIS OVERLAY'S OVL.ENT BYTE
	XCHG
	LHLD	S.OVLE
	XCHG			(DE) = OVERLAY ENTRY ADDRESS
	MOV	M,E
	INX	H
	MOV	M,D		SET OVERLAY ENTRY ADDRESS IN OVERLAY TABLE
	JMP	LDON0		RETURN

LDON5	MVI	A,EC.IOI	ILLEGAL OVERLAY INDEX
	STC			FLAG ERROR
	JMP	LDON1

LDON6	INX	SP
	INX	SP		REMOVE OLD (PSW) FROM STACK
	STC			FLAG ERROR
	JMP	LDON1
	SPACE	4,10
*	FATAL SYSTEM ERROR

FATSERR CALL	$TYPTX
	DB	NL,BELL,'?02 FATAL SYSTEM ERROR ?',BELL,ENL
FATSER1 XRA	A
	STA	.MFLAG
	OUT	SC.UART+USR	CLEAR CONSOLE UART
	OUT	SC.ACE+UR.IER
	EI
	HLT
	JMP	FATSER1
	STL	'EXIT - PROCESS EXIT SYSCALL'
	EJECT
***	EXIT - EXIT USER PROGRAM.
*
*	EXIT IS CALLED TO RETURN CONTROL TO THE SYSTEM COMMAND
*	PROGRAM.
*
*	MVI	A,FLAG		=0 FOR NORMAL, =1 FOR ABORT
*	DB	SYSCALL,.EXIT
*
*	FOR A NORMAL EXIT, THE CONTROL CHARACTER VECTORS ARE CLEARED.
*	AND SYSCMD IS ENTERED.
*
*	FOR AN ABORT EXIT, THE DISK DRIVER IS RESET.
*
*	/79.06.gc/	IF  ( NO SYSTEM DISK  AND  S.ALONE IS SET)
*					OR
*			    ( SYSTEM DISK IS STILL MOUNTED )
*
*			    NORMAL LINK TO *SYSCMD.SYS*
*
*			ELSE
*
*			  EXIT TO REBOOT CODE
*

	
EXIT	EQU	*
	LXI	SP,STACK		RESET STACK		/79.12.GC/
	PUSH	PSW			SAVE CODE FOR LINKED PROGRAM
	ANA	A			SET CONDITION CODES
	MVI	A,UO.CLK+UO.HLT
	STA	.MFLAG			REFRESH MFLAG
	JZ	EXIT1			NOT TO ABORT

	XRA	A			System unit		/80.05.gc/
*	LDA	SUNIT
	STA	AIO.UNI			SET SYSTEM DISK
	MVI	A,DC.ABT
	CALL	SYDD			ABORT SYSTEM DISK

EXIT1	SCALL	.CLEARA			CLEAR ALL BUT THE LINK CHANNEL
	LDA	S.MOUNT
	ANA	A
	JNZ	EXIT2			SYSTEM IS MOUNTED
	LDA	SALONE
	ANA	A
	JZ	EXIT3			STAND-ALONE SWITCH IS NOT SET

*	LOAD EXIT OVERLAY

EXIT2	POP	PSW			RESTORE LINK CODE
	LXI	H,EXITA
	LXI	SP,STACK		RESET STACK
	SCALL	.LINK			LINK TO EXIT PROCESSOR

*	COULD NOT LINK

	PUSH	PSW			SAVE CODE
	LDA	S.MOUNT
	ANA	A
	JNZ	EXIT4			CONSIDERED FATAL BECAUSE SYSTEM DISK

EXIT3	LXI	H,EXITC							/2.0a/
	SCALL	.PRINT			MAKE SURE WE ARE ON A NEW LINE
	MVI	A,-1
	SCALL	.CLEAR			CLEAR THE LINK CHANNEL

*	Boot a new disk							/2.0a/
	XRA	A
	ERRNZ	OVL0
	SCALL	.LOADO			Load *HDOSOVL0*
	CC	FATSERR
	MVI	A,OVL1
	SCALL	.LOADO			Load *HDOSOVL1*
	CC	FATSERR
	SCALL	.DAD			Dismount all disks
	CC	FATSERR
	CALL	BND			Read in the boot track
	LXI	SP,STACK						/2.0c/
	JMP	SB.BOO

*	ERROR	-  COULD NOT LINK TO   *SY0:SYSCMD.SYS*

EXIT4	LXI	H,EXITB
	SCALL	.PRINT			PRINT MESSAGE
	POP	PSW			(A) = CODE
	MVI	H,0
	SCALL	.ERROR			TYPE ERROR
	CALL	FATSERR			HALT

EXIT5	SCALL	.DMOUN
	RNC				NO ERROR
	CPI	EC.NVM
	RZ				NO VOLUME MOUNTED NOT CONSIDERED FATAL
	SCALL	.ERROR
	CALL	FATSERR			HALT
EXITB	DB	NL,BELL,'?02 Cant Run '
EXITA	DB	'SY'			System Device		/80.05.gc/
	DB	'0:SYSCMD.SYS',0,ENL	System Unit		/80.05.gc
EXITC	DB	ENL							/2.0a/
	STL	'SCIN'
	EJECT
***	SCIN - SYSTEM CONSOLE INPUT.
*
*	SCIN TAKES A SINGLE CHARACTER FROM THE CONSOLE INPUT
*	BUFFER, IF ANY ARE AVAILABLE.
*
* L1	DB	SYSCALL,.SCIN
*	JC	L1		CHARACTER NOT READY
*
*	ENTRY	NONE
*	EXIT	'C' SET IF NO CHARACTER
*		'C' CLEAR IF CHARACTER
*		 (A) =CHARACTER
*	USES	A,F


SCIN	EQU	*
	LDA	S.CSLMD
	ERRNZ	CSL.CHR-1
	RAR
	PUSH	H		SAVE (HL)
	CALL	SCIN1		GET CHARACTER
	EI
	POP	H
	RET

**	GET CHARACTER FROM BUFFER.

SCIN1	DI
	JC	SCIN2		NOT LINE MODE

*	LINE INPUT FORM

	LDA	CSLLCNT
	SUI	1		'C' SET IF NO LINES
	RC			NO LINE YET

*	TAKE CHARACTER

SCIN2	LHLD	SCIOUT
	LDA	SCIIN
	CMP	L		SEE IF EMPTY
	STC
	RE			EMPTY
	MOV	A,M		(A) = CHARACTER
	PUSH	PSW
	CALL	ABP		ADVANCE BUFFER POINTER
	SHLD	SCIOUT		UPDATE POINTER
	POP	PSW		(A) - CHARACTER READ

*	MAP LOWER CASE TO UPPER, IF 'CTP.MLI' SET

	CPI	'a'		LOWER CASE 'A'
	JC	SCIN2.5		NOT LWOER CASE
	CPI	'z'+1		LOWER CASE 'Z'
	JNC	SCIN2.5		NOT LOWER CASE
	MOV	H,A		(H) = CHARACTER
	LDA	S.CONTY
	ERRNZ	'a'-'A'-CTP.MLI
	ANI	CTP.MLI		(A) = 040Q IF TO MAP
	XRA	H		(A) = MAPPED CHARACTER
SCIN2.5 CPI	NL
	JE	SCIN3		IS NEW LINE
	CPI	CTLD		SEE IF CTLD
	JE	SCIN3		Is New Line			/2.0a/
	ANA	A		F = 'NC', A = character		/2.0a/
	RET							/2.0a/

*	END OF LOGICAL LINE
SCIN3	LXI	H,CSLLCNT
	DCR	M		COUNT LINE
	RP			NOT UNDERFLOW
	MVI	M,0
	RET
	STL	'CONSOLE INPUT INTERRUPT'
	EJECT
**	SCINI - SYSTEM CONSOLE INPUT INTERRUPT.
*


SCINI	EQU	*
	PUSH	PSW
	PUSH	H
	CALL	SCINI0		PROCESS CHARACTER
	POP	H
	CALL	CPA		CHECK FOR PENDING ABORT
	POP	PSW
	EI
	RET			EXIT

*	PROCESS CHARACTER INTERRUPT

SCINI0	LDA	S.CDB
	CPI	CDB.H84
	JZ	SCINI01			IF  8250

*	HAVE 8251
	IN	SC.UART+UDR
	JMP	SCINI02

*	HAVE 8250

SCINI01 IN	SC.ACE+UR.RBR

SCINI02 ANI	177Q		TRIM PARITY
	CALL	CRM		Check Raw Mode				/2.0a/
	JNZ	SCINI4		Ignore special character proc.		/2.0a

	ANA	A							/2.0a/
	RZ			NULL CHARACTER
	CPI	LF
	RE			IGNORE LINE-FEEDS

*	SEE IF SPECIAL CONTROL CHARACTER:
*
*	CTL-A,B,C, CTL-Z, CTL-O, CTL-P, CTL-Q, CTL-S

	CPI	CTLZ
	JE	SCINI2		CTL-Z
	CPI	04
	JNC	SCINI3		NOT CTL-A, CTL-B, OR CTL-C
	XRI	2		CANCEL EFFECT OF NEXT INSTRUCTION

*	HAVE CTL-A,B,C OR CTL-Z

SCINI2	XRI	2		REMOVE '2' BIT IN ^Z (32Q -> 30Q)
	ANI	CC.FLG+CZ.FLG	MASK OFF FLAG
	JMP	PSC		PROCESS SPECIAL CHARACTER AND EXIT

*	SEE IF CTL-O THROUGH CTL-S

SCINI3	STA	SCIPRE		SET PREVIOUS CHARACTER
	CPI	CTLO
	JC	SCINI4		NONE OF THESE
	CPI	'T'-'@'
	JNC	SCINI4		NONE OF THESE
	CPI	'R'-'@'
	JE	SCINI4		DONT TAKE CTL-R

*	IS CTL-O THROUGH CTL-S

SCINI35 ADD	A		(A) = 2 * CODE			/80.04.GC/
	LXI	H,SCINIA-'O'-'O'+'@'+'@'	(HL) = TABLE FWA - BIAS
	CALL	$DADA.		(HL) = TABLE ADDRESS
	LDA	S.CONFL
	ANA	M		CLEAR BITS
	INX	H
	XRA	M		SET BITS
	STA	S.CONFL
	RET			DONE

*	IS NOT AN 'ANYTIME' CONTROL CHARACTER. SEE IF LINE MODE

SCINI4	MOV	H,A		(H) = CHARACTER
	LDA	S.CSLMD
	ERRNZ	CSL.CHR-1
	RAR
	JC	SCINI8		IS CHARACTER MODE

*	IS LINE MODE. SEE IF RUBOUT OR CTL-U

	LDA	S.CONTY
	ANI	CTP.BKM		SEE IF MAPPING BKSP TO RUBOUT
	JZ	SCIN4.3		NOT MAPPING
	MVI	A,BKSP
	CMP	H
	JE	SCIN4.5		IS BKSP/RUBOUT
SCIN4.3 MOV	A,H
	INR	A
	JP	SCINI6		NOT RUBOUT

*	IS RUBOUT. TYPE FLAGS AND REMOVE CHARACTER

SCIN4.5 CALL	RRC		REMOVE REGULAR CHARACTER
	RE			NONE TO REMOVE
	MOV	H,A		(H) = REMOVED CHARACTER
	LDA	S.CONTY
	ERRNZ	CTP.BKS-200Q
	ANA	A
	JM	SCINI11		CAN BACKSPACE: ECHO <BKSP BLANK BKSP>
	LDA	CSLRBF
	XRI	'/'
	JZ	SCINI5		ALREADY SET
	STA	CSLRBF
	PUSH	H
	CALL	SCOUT1		TYPE '/'
	POP	H
SCINI5	MOV	A,H
	JMP	SCOUT1		ECHO CHARACTER

SCINI6	LDA	CSLRBF
	XRI	'/'		SEE IF RUBOUT PENDING
	JNZ	SCINI65		NOT PENDING
	STA	CSLRBF		SLEAR FLAG
	MVI	A,'/'
	PUSH	H
	CALL	SCOUT1
	POP	H
SCINI65 MOV	A,H		(A) = INPUT CHARACTER
	CPI	'U'-'@'
	JNE	SCINI8		NOT CTL-U

*	IS CTL-U

SCINI7	CALL	RRC		REMOVE REGULAR CHARACTER
	JNZ	SCINI7		MORE TO GO
	MVI	A,'^'
	CALL	SCOUT2		TYPE ^
	MVI	A,'U'
	CALL	SCOUT2		TYPE 'U'
	JMP	CRLF		NEW LINE AND EXIT

*	HAVE REGULAR CHARACTER. STORE IF ROOM

SCINI8	PUSH	H		SAVE CHAR
	LHLD	SCIIN
	PUSH	H		SAVE IN POINTER
	CALL	ABP		ADVANCE BUFFER POINTER
	LDA	SCIOUT
	CMP	L
	JNE	SCINI9		HAVE ROOM
	
*	TOO FULL. BEEP CHARACTER

	POP	H
	POP	PSW
	MVI	A,BELL
	JMP	SCOUT1		BEEP

*	HAVE ROOM. WILL STORE CHARACTER

SCINI9	SHLD	SCIIN
	POP	H		(HL) = POINTER
	POP	PSW		(A) = CHAR
	MOV	M,A		STORE
	CPI	CTLD
	JE	SCINI95		IS CTL-D

*	Conditionally map CR to NL

	CALL	CRM		Check Raw Mode
	JNZ	SCINI93		Don't map because of raw mode
	CPI	CR
	JNE	SCINI93		NOT CR
	MVI	A,NL
	MOV	M,A		STORE NL

SCINI93 CPI	NL
	JNZ	SCINI10		Not the end of a line

*	HAVE SEEN END OF LOGICAL LINE

SCINI95 LXI	H,CSLLCNT
	INR	M		COUNT LINE
SCINI10 MOV	H,A		(H) = CHAR

*	SEE IF TO ECHO

	LDA	S.CSLMD
	ERRNZ	CSL.ECH-200Q
	RAL
	MOV	A,H		(A) = CHA
	JNC	SCOUT1		AM TO ECHO
	RET			SUPRESS ECHO

*	HAVE BACKSPACE FOR TERMINAL WITH BACKSPACE CAPABILITY:
*	ISSUE BKSP, BLANK, BKSP

SCINI11 MVI	A,BKSP
	CALL	SCOUT2
	MVI	A,' '
	CALL	SCOUT2		PRINT BKSP, <BLANK>, BKSP
	MVI	A,BKSP
	JMP	SCOUT2		PRINT AND EXIT


**	PROCESSING FOR CTL-P, CTL-O, CTL-Q, CTL-S
*
*	FIRST BYTE = CLEAR MASK FOR S.CONFL
*	2ND BYTE = XOR MASK FOR S.CONFL

SCINIA	DB	-1,CO.FLG	CTL-O
	DB	377Q-CO.FLG,0	CTL-P
	DB	377Q-CS.FLG,0	CTL-Q
	DB	-1,0		CTL-R
	DB	377Q-CS.FLG,CS.FLG	CTL-S
	SPACE	4,10
**	PSC - PROCESS SPECIAL CHARACTER.
*
*	PSC IS CALLED WHEN A SPECIAL INTERRUPT CHARACTER IS DETECTED
*	(CTL-A, CTL-B, CTL-C, CTL-Z). PSC DECIDES IF SPECIAL
*	SERVICE WILL BE NEEDED (IF REQUESTED BY USER FOR CTL-A, -B, AND -C,
*	OR UPON 2ND CTL-Z)
*
*	IF SERVICE IS NEEDED, THE SERVICE ADDRESS IS STORED IN
*	S.CADDR.
*
*	ENTRY	(A) = CHARACTER DETECTED
*	EXIT	S.CADDR > 256 IF PROCESSING NEEDED
*	USES 	A,F,H,L


PSC	PUSH	B
	CALL	PSC1		PROCESS
	POP	B
	RET

PSC1	MOV	B,A		(B) = CHARACTER
	ANI	CZ.FLG
	JNZ	PSC2		IS CTL-Z

*	IS CTL-A, -B, OR -C

	MOV	A,B
	ADD	A		(A) = 2*CODE
	RZ			NONE
	LXI	H,S.CCTAB-2
	CALL	$DADA.		(HL) = ADDRESS OF ADDRESS
	CALL	$HLIHL
	MOV	A,H
	ANA	A
	RZ			NONE TO SET
	SHLD	S.CAADR		SET CONSOLE ABORT ADDRESS
	RET

*	IS CTL-Z

PSC2	LDA	S.MOUNT
	ANA	A
	RZ			SYSTEM NOT MOUNTED, IGNORE
	EI
	MVI	A,'^'
	CALL	SCOUT1
	MVI	A,'Z'
	CALL	SCOUT1
	LDA	SCIPRE
	CPI	CTLZ
	JE	PSC3		2ND CTL-Z
	MVI	A,CTLZ
	STA	SCIPRE		SET CTL-Z AS PREVIOUS CHARACTER

*	TYPE '?' WARNING

	MVI	A,'?'
	JMP	SCOUT1		OUTPUT AND RETURN

*	2ND CTL-Z HIT

PSC3	MVI	A,CTLQ						/80.04.gc/
	CALL	SCINI35		simulate CTL-Q			/80.04.gc/
	LXI	H,EXIT
	SHLD	S.CAADR		CONSOLE ABORT ADDRESS
	RET
	STL	'SCOUT - SYSTEM CONSOLE OUTPUT'
	EJECT
**	SCOUT - SYSTEM CONSOLE OUTPUT.
*
*	SCOUT OUTPUTS A SINGLE CHARACTER TO THE CONSOLE. CURSOR POSITOINING
*	IS KEPT TRACK OF, A 'NL' CHARACTER INDICATES A NEW LINE, 'CR' AND
*	'LF' CHARACTERS SHOULD NOT BE USED.
*
*	NOTE THAT THERE ARE SOME GAMES PLAYED WITH THE PARITY BIT.
*	SEE *CRLF* FOR DISCUSSION.
*
*	MVI	A,CHAR
*	DB	SCALL,.SCOUT
*
*	ENTRY	(A) = CHARACTER
*	EXIT	(A) = CHARACTER
*	USES	NONE


SCOUT	EQU	*
	PUSH	PSW		SAVE CHAR
	PUSH	H		SAVE (HL)
	MOV	H,A		(A) = CHARACTER
SCOUT0	LDA	S.CONFL
	ERRNZ	CS.FLG-200Q
	ANA	A
	JM	SCOUT0		AM IN WAIT MODE
	ERRNZ	CO.FLG-1
	RAR
	MOV	A,H		(A) = CHARACTER
	CNC	SCOUT1		PERFORM I/O IF NOT CTL-O
	POP	H
	POP	PSW
	RET
	SPACE	4,10
**	SCOUT1 - OUTPUT CHARACTER.
*
*	SCOUT1 IGNORES CTL-O AND CTL-S, AND IS USED BY HDOS CODE
*	WHICH MUST NOT BE HELD UP.
*
*	SCOUT1 MAY BE CALLED WITH INTERRUPTS DISABLED.
*
*	ENTRY	(A) = CHARACTER
*	EXIT	NONE
*	USES	A,F,H,L

SCOUT1	ANI	177Q		TRIM

*	IF LOWER CASE MAPPING TURNED ON, DOIT

	CPI	140Q
	JC	SCOUT2		NOT LOWER CASE
	MOV	H,A
	LDA	S.CONTY
	ADD	A
	ANI	CTP.MLO*2	(A) = 040Q IF MAPPING
	XRA	H		CLEA BIT IF MAPPING


**	SOME ROUTINES CALL HERE (SCOUT ITSELF, RECURSIVELY)
*	TO OUTPUT CHARACTERS WITHOUT THE CPU OVERHEAD OF  SCOUT OR
*	SCOUT1.

SCOUT2	CPI	TAB
	JNE	SCOUT4		NOT TAB

*	HAVE TAB, EXPAND TO COLUMN

	LDA	S.CONTY
	ERRNZ	CTP.TAB-1
	RAR
	MVI	A,TAB
	JC	SCOUT4		TERMINAL WILL TAKE TABS
SCOUT3	MVI	A,' '
	CALL	SCOUT4		TYPE BLANK
	LDA	S.CUSOR
	DCR	A
	ANI	7
	JNZ	SCOUT3		NOT TO FIELD
	RET			DONE

*	TYPE CHARACTER. (A) =CHARACTER

SCOUT4	CALL	CRM		Check Raw Mode				/2.0a/
	JNZ	SCOUT45		Don't map NL				/2.0a/
	CPI	NL
	JE	CRLF		IS A NEW LINE
	
SCOUT45 LXI	H,S.CUSOR	(M) = CONSOLE CURSOR POINTER		/2.0a/
	CPI	CR
	JNE	SCOUT5		NOT CR
	MVI	M,1		CLEAR POINTER
SCOUT5	CPI	BKSP
	JNE	SCOUT6		IS NOT BKSP
	DCR	M
	JNZ	SCOUT6		NOT UNDERFLOW
	MVI	M,1		RESET
SCOUT6	CPI	TAB
	JNE	SCOUT7		NOT TAB
	MOV	A,M
	ADI	7Q
	ANI	370Q
	INR	A		ADJUST COLUMN COUNT TO NEXT TAB
	MOV	M,A
	MVI	A,TAB
SCOUT7	ANI	177Q		TRIM TO 7 BITS
	CPI	' '		SEE IF PRINTING
	JC	SCOUT8		NOT PRINTING

*	CHECK FOR CHARACTER WRAP?

	PUSH	PSW		SAVE CURRENT CHARACTER
	INX	H
	ERRNZ	S.CONWI-S.CUSOR-1
	MOV	A,M		(A) = CONSOLE WIDTH
	DCX	H
	ERRNZ	S.CONWI-S.CUSOR-1
	CMP	M
	CC	CRLF		WIDTH < S.CURSOR AND ABOUT TO OUTPUT A PRINTING
	POP	PSW		 CHARACTER

	INR	M		COUNT CHARACTER

*	OUTPUT CHARACTER.

SCOUT8	MOV	H,A		Save Character				/2.0a/
	LDA	S.CONTY							/2.0a/
	ANI	CTP.FF		Check for Form Feed Proc.		/2.0a/
	MOV	A,H		Restore Character			/2.0a/
	JNZ	SCOUT85		Don't Check Form Feed Proc.		/2.0a/
	CPI	FF
	JE	SCOUT10		IS FORM FEED
	
SCOUT85 PUSH	PSW		SAVE CHAR
SCOUT9	LDA	S.CDB
	CPI	CDB.H84
	JZ	SCOUT92		IF 8250

*	HAVE 8251

SCOUT91	IN	SC.UART+USR
	ANI	USR.TXR
	JZ	SCOUT91		NOT READY
	POP	PSW
	OUT	SC.UART+UDR
	JMP	SCOUT95

*	HAVE 8250

SCOUT92 IN	SC.ACE+UR.LSR
	ANI	UC.THE
	JZ	SCOUT92
	POP	PSW
	OUT	SC.ACE+UR.THR

SCOUT95 CPI	377Q		SEE IF TO PAD
SCOUTA	EQU	*-1
	CE	SCDLY		MUST DELAY FOR PADS
	RET							/79.04.GC/

*	IS FORM FEED

SCOUT10 MVI	A,10
SCOUT11 PUSH	PSW		SAVE LINE FEED COUNT
	MVI	A,LF+200Q
	CALL	SCOUT2		OUTPUT LINE FEED
	POP	PSW
	DCR	A
	JNZ	SCOUT11		MORE TO GO
	RET
	SPACE	3,10
**	SCDLY - ISSUE DELAY (VIA 00 CHARACTERS)
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	A,F


SCDLY	LDA	CSLDLY
SCDLY1	ANA	A
	RZ			NO MORE PADS
	PUSH	PSW
	PUSH	H		SAVE REGISTERS
	XRA	A
	CALL	SCOUT2		WRITE PAD
	POP	H
	POP	PSW
	DCR	A
	JMP	SCDLY1		DELAY UNTIL DONE
	SPACE	4,10
**	CRLF - START NEW LINE.
*
*	NOTE THAT CRLF DOESNT WANT THE 'LF' TO BE TAKEN AS A
*	'NL', AND THUS TRIGGER A RECURSIVE LOOP. WE CAN GET AROUND THAT
*	BY SETTING THE PARITY BIT FOR IT, SO THAT IT FAILS THE
*	CPI	NO
*	TEST. THE PARITY BIT IS STRIPPED (AGAIN, FOR MOST) BEFORE
*	THE CHAR IS PASSED TO THE USART.
*	ENTRY	NONE
*	EXIT	NONE
*	USES	A,F


CRLF	PUSH	H		SAVE (HL)
	MVI	A,CR
	CALL	SCOUT1
	MVI	A,LF+200Q
	CALL	SCOUT2		OUTPUT IT
	POP	H
	RET
	SPACE	4,10
**	CRM	- Check Raw Mode
*
*	CRM checks the raw mode flag.  This routine should be
*	called before certain character mapping and processint
*	is done
*
*	ENTRY:	S.CSLMD = Current Console Mode
*
*	EXIT:	PSW	= 'Z'	If NOT Raw Mode
*			  'NZ'  if     Raw Mode
*
*	USES:	F
*

CRM	PUSH	H
	MOV	H,A
	LDA	S.CSLMD		A = Current Console Mode
	ANI	CSL.RAW		Set Flags accordingly
	MOV	A,H		Restore A
	POP	H
	RET
	STL	'READ - PROCESS READ COMMAND.'
	EJECT
***	READ - PROCESS READ SYSCALL.
*
*	READ PROCESSES READ SYSCALLS. IF A SERIAL DEVICE, PASS TO
*	DRIVER. IF A STORAGE DEVICE, HANDLE STORAGE MAPPING.
*
*	MVI	A,CHAN
*	LXI	B,COUNT		MUST BE MULTIPLE OF 256
*	LXI	D,ADDR
*	DB	SYSCALL,.READ	READ DATA FROM CHANNEL
*
*	ENTRY	(A) = I/O CHANNEL NUMBER
*		(BC) = DATA COUNT
*		(DE) = ADDRESS FOR DATA
*	EXIT	(BC) = COUNT LEFT
*		(DE) = NEXT UNUSED ADDRESS
*		'C' CLEAR IF ALL OK
*		'C' SET IF ERROR
*		 (A) = ERROR CODE
*	USES	ALL


READ	CALL	FCI		FETCH CHANNEL INFO
	RC			ERROR
	ANA	A
	JZ	ERR.FNO		FILE NOT OPEN
	ERRNZ	FT.OR-2
	RAR
	RAR
	JNC	ERR.ILR		ILLEGAL REQUEST
	ERRNZ	FT.DD-1
	RAL
	MVI	A,DC.REA	(A) = DEVICE CODE
	JNC	AIO.VEC		IF NOT DIRECTORY DEVICE, CALL DRIVER
	CALL	DIREAD		DIRECTORIED READ
	JMP	SCI		STORE CHANNEL INFORMATION AND EXIT
	STL 	'WRITE - PROCESS WRITE COMMAND'
	EJECT
***	WRITE - PROCESS WRITE SCALL.
*
*	MVI	A,CHAN
*	LXI	B,COUNT		MUST BE MULTIPLE OF 256
*	LXI	D,ADDR
*	DB	SYSCALL,.WRITE	WRITE DATA TO CHANNEL
*
*	ENTRY	(A) = CHANNEL #
*		(BC) = DATA COUNT
*		(DE) = ADDRESS
*	EXIT	(BC) = COUNT LEFT
*		(DE) = NEXT ADDRESS
*		'C' CLEAR IF OK
*		'C' SET IF ERROR
*		 (A) = ERROR CODE
*	USES	ALL


WRITE	CALL	FCI		FETCH CHANNEL INFORMATION
	RC			ERROR
	ANA	A
	JZ	ERR.FNO		FILE NOT OPEN
	MOV	H,A		SAVE COPY IN H
	ANI	FT.OW		SEE IF OPEN FOR WRITE
	JZ	ERR.ILR		ILLEGAL REQUEST
	MOV	A,H
	ERRNZ	FT.DD-1
	RAR
	MVI	A,DC.WRI	REQUEST WRITE
	JNC	AIO.VEC		NOT A DIRECTORY DEVICE
	CALL	DIWRITE		DIRECTORIED WRITE
	JMP	SCI		STORE CHANNEL INFO
	STL	'PRINT - PROCESS PRINT SYSCALL.'
	EJECT
***	PRINT - PRINT CONSOLE LINE.
*
*	PRINT CAUSES A CODED LINE TO BE PRINTED AT THE CONSOLE.
*
*	LXI	H,LINEADDR
*	DB	SYSCALL,.PRINT
*
*	THE LAST CHARACTER IN THE LINE SHOULD HAVE THE 200Q BIT SET.
*
*	ENTRY	(HL) = LINE ADDRESS
*	EXIT	(HL) = LWA OF MESSAGE +1
*	USES	A,F,H,L


PRINT	MOV	A,M		(A) = CODE
	ANI	177Q		CLEAR FLAG BIT
	CALL	SCOUT		TYPE IT
	CMP	M
	INX	H
	JE	PRINT		NOT 200Q SET
	RET
	STL	'CONSL  - SET/CLEAR CONSOLE FLAGS.'
	EJECT
***	CONSL - SET AND CLEAR CONSOLE FLAGS.
*
*	CONSL IS CALLED TO SET, CLEAR, OR READ BITS IN THE VARIOUS
*	CONSOLE FLAGS.
*
*	THE CALLER PASSES AN INDES INTO THE PROPER FLAG, A
*	MASK TO INDICATE THE EFFECTED BITS, AND A SET OF NEW VALUES
*	FOR THOSE BITS.
*
*	INDEX =
*
*	O	S.CSLMD
*	1	S.CONTY
*	2	S.CUSOR
*	3	S.CONWI
*	4	S.CONFL
*
*	ENTRY	(A) = INDEX
*		(B) = NEW VALUES
*		(C) = MASK ('1' BIT FOR EVERY BIT TO CHANGE)
*	EXIT	'C' CLEAR IF NO ERROR
*		 (A) = NEW VALUE
*		'C' SET IF ERROR
*		 (A) = ERROR CODE
*	USES	ALL


CONSL	EQU	*
	CPI	5
	JNC	ERR.ILR		ILLEGAL REQUEST
	LXI	H,S.CSLMD
	CALL	$DADA.		(HL) = ADDRESS FOR BYTE
	MOV	A,C
	ANA	B		CLEAR (B) TO THE BITS TO BE ALTERED
	MOV	B,A
	MOV	A,C
	CMA			(A) = -MASK
	DI			INTERLOCK CONSOLE
	ANA	M		CLEAR EFFECTED BITS
	ORA	B		SET NEW VALUES
	MOV	M,A		REPLACE
	EI
	RET
	STL	'CLRCO - CLEAR CONSOLE BUFFERS'
	EJECT
***	CLRCO - CLEAR CONSOLE BUFFERS.
*
*	CLRCO CLEARS THE CONSOLE TYPE-AHEAD BUFFER.
*	CTL-O AND CTL-S FLAGS ARE ALSO CLEARED.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALLL


CLRCO	DI
	LXI	H,CSLIBUF
	SHLD	SCIIN
	SHLD	SCIOUT		CLEAR POINTER
	XRA	A
	STA	CSLLCNT		CLEAR LINE COUNT
	STA	CSLRBF		CLEAR RUBOUT BUFFER
	STA	S.CONFL		CLEAR CTL-O AND CTL-S
	EI
	RET
	STL	'LOADO	- LOAD SPECIFIED OVERLAY'
	EJECT
***	LOADO	 - LOAD SPECIFIED OVERLAY
*
*	LOADO LOADS THE OVERLAY SPECIFIED THROUGH THE INDES.
*
*		OVERLAY	      INDEX
*	      -----------------------
*		HDOSOVL		0
*		HDOSOVL2	1
*
*	**********************************************************************
*	*								     *
*	*	NOTE:	THIS CALL SHOULD NOT BE MADE FROM ANOTHER OVERLAY    *
*	*		UNLESS IT IS THE OVERLAY TO BE LOADED		     *
*	*								     *
*	**********************************************************************
*
*	ENTRY:	(A)	= OVERLAY INDEX
*
*	EXIT:	(PSW)	='C' CLEAR IF NO ERRORS
*			 'C' SET   IF    ERRORS
*			  (A)  = ERROR CODE
*
*	USES:	ALL
*

LOADO	PUSH	PSW		SAVE THE OVERLAY INDEX
	CALL	LDON		LOAD THE SPECIFIED OVERLAY
	JC	LOADO2		ERROR
	LDA	S.OVLFL
	ANI	OVL.UCS
	JNZ	LOADO1		USER CODE IS SWAPPED
	POP	PSW		RESTORE OVERLAY INDEX
	CALL	OTI		OVERLAY TABLE INDEX
	DW	OVL.FLB		(HL) = ADDRESS OF FLAG BYTE
	MOV	A,M
	ANI	OVL.RES
	RNZ			IT IS ALREADY RESIDENT
	MOV	A,M
	ORI	OVL.RES
	MOV	M,A		FLAG OVERLAY AS PERM RESIDENT
	DCX	H
	DCX	H		(HL) = OVERLAY ENTRY POINT
	ERRNZ	OVL.FLB-OVL.ENT-2
	CALL	$HLIHL		(HL) = ENTRY ADDRESS
	SHLD	S.SYSM		SET OVERLAY ENTRY POINT AS HDOS LOWER BOUND
	RET
	
LOADO1	MVI	A,EC.NEM	NOT ENOUGH MEMORY
LOADO2	STC			FLAG ERROR
	POP	H		REMOVE SAVED OVERLAY INDEX
	RET
	STL	'VERSN 	-RETURN HDOS VERSION NUMBER'
	EJECT
**	VERSN 	- RETURN HDOS VERSION NUMBER'
*
*	VERSN RETURNS THE HDOS VERSION NUMBER AS A ONE BYTE BCD NUMBER.
*	A DECIMAL IS ASSUMED BETWEEN THE HIGH AND LOW ORDER NIBBLES.
*
*
*	ENTRY	NONE
*
*	EXIT	(PSW)	= (A) = VERSION NUMBER
*
*	USES	(PSW)
*

VERSN	MVI	A,VERS
	ANA	A		CLEAR CARRY
	RET
	STL	'DISK I/O SUBROUTINES'
	EJECT
**	DIREAD - DIRECTORIED READ.
*
*	DIREAD REASD THE SPECIFIED NUMBER OF SECTORS FROM A
*	DIRECTORIED DEVICE. THE DATA IS RAD FROM THE CURRENT
*	FILE POSITION.
*
*	ENTRY	(B) = SECTOR COUNT
*		(C) = 9
*		(DE) = ADDRESS FOR DATA
*		AIO.XXX SETUP
*	EXIT	(BC) = COUNT LEFT
*		(DE) = NEXT FREE ADDRESS
*		'C' CLEAR IF OK
*		'C' SET OF ERROR
*		 (A) = CODE
*	USES	ALL


DIREAD	EQU	*
	MOV	A,B
	ANA	A
	RZ     			NOTHING TO READ
	PUSH	D		SAVE (DE)
	CALL	DCA		DETERMINE CONTINUOUS AREA
	POP	D
	LDA	AIO.EOF
	RAR
	RC			EXIT IF EOF
	PUSH	B
	CALL	PDI		PREPARE DEVICE I/O
	ERRNZ	DC.REA
	CALL	DIREAD1		PERFORM I/O
	POP	B
	JNC	DIREAD		IF NOT ERROR
	RET
	SPACE	3,10
**	DIREAD1 - PERFORM I/O
*
*	DIREAD1 CALLS THE I/O DRIVER, AFTER COMPUTING THE COMPLETION ADDRESS
*	(WHICH THE DRIVER WILL NOT RETURN)
*
*	ENTRY	(A) = OPERATION CODE
*		(BC) = COUNT
*		(DE) = ADDRESS
*		(HL) = SECTOR NUMBER
*	EXIT	(PSW) AS FOM DRIVER
*		(BC) AS FROM DRIVER
*		(DE) = (BC ON ENTRY) + (DE ON ENTRY)
*		(HL) AS FROM DRIVER
*	USES	ALL


DIREAD1 XCHG			(HL) = I/O ADDRESS
	PUSH	H		SAVE
	DAD	B		(HL) = NEW ADDRESS
	XTHL			(HL) = I/O ADDRESS ((SP)) = NEW ADDRESS
	XCHG			RESTORE AS UPON ENTRY
	CALL	AIO.VEC		CALL DRIVER
	POP	D		(DE) = NEW ADDRESS
	RET
	SPACE	4,10
**	DIWRITE - DIRECTORY DEVICE WRITE.
*
*	DIWRITE WRITES THE SPECIFIED NUMBER OF SECTORS TO A DIRECTORIED
*	DEVICE.
*
*	ENTRY	(B) = COUNT
*		(C) = 0
*		(DE) = TEXT ADDRESS
*		AIO.XXX SETUP
*	EXIT	(BC) = COUNT LEFT
*		(DE) = ADDRESS
*		'C' CLEAR, IF OK
*		'C' SET IF ERROR
*		 (A) = ERROR CODE
*	USES ALL


DWRIT1	PUSH	B		SAVE COUNT
	CALL	PDI		PREPARE FOR DEVICE I/O
	MVI	A,DC.WRI
	CALL	DIREAD1		PERFORM I/O
	POP	B		(BC) = COUNT LEFT
	MVI	A,EC.WF		WRITE FAIL (IF CARRY SET)
	RC			RETURN IF ERROR

DIWRITE EQU	*
	MOV	A,B
	ANA	A
	RZ			NO MORE
	PUSH	D
	CALL	DCA		DETERMINE CONTIGUOUS AREA
	POP	D
	LDA	AIO.EOF
	RAR
	JNC	DWRIT1		IF NOT EOF

*	MUST APPEND SECTORS TO END OF THE FILE.
*	ALLOCATE THE SPACE.

DWRIT2	EQU	*
	MOV	A,B
	ANA	A
	RZ			NO MORE
	LHLD	AIO.CHA
	MVI	A,IOC.DIR+DIR.FLG-IOC.DDA
	CALL	$DADA.		(HL) = #DIR.FLG IN CHANNEL
	MOV	A,M
	ANI	377Q-DIF.CNT	IS NOT CONTIGUOUS ANY MORE (IF IT EVER WAS)
	MOV	M,A
	PUSH	D
	CALL	ACA		ALLOCATE CONTINUOUS AREA
	POP	D
	LDA	AIO.EOM
	RAR
	RC			EXIT IF EOM

*	NOT OUT OF SPACE. WRITE IT

	PUSH	B
	CALL	PDI		PREPARE DEVICE I/O
	MVI	A,DC.WRI
	CALL	DIREAD1		PERFORM I/O
	POP	B
	JNC	DWRIT2		GO AGAIN
	RET			RETURN WITH ERROR CODE
	STL	'RESIDENT SUBROUTINES'
	EJECT
**	ABP - ADVANCE BUFFER POINTERS.
*
*	ABP ADVANCES THE BUFFER POINTER TO THE NEXT BYTE. IF THE
*	POINTER OVERFLOWS, IT IS WRAPPED.
*
*	ENTRY	(HL) = POINTER
*	EXIT	(HL) = POINTER TO NEXT
*	USES	A,F,H,L

	
ABP	INX	H		INCREMENT
	LDA	SCILWA
	CMP	L
	RNE			NOT OVER END
	LHLD	SCIFWA
	RET
	SPACE	4,10
**	ACA - ALLOCATE CONTINUOUS AREA
*
*	ACA IS CALLED TO APPEND SECTORS TO THE END OF A FILE.
*	IT ALLOCATES AS MANY CONTINUOUS SECTORS AS IT CAN UNTIL
*	ENOUGH ARE ALLOCATED, OR A BREAK IN THE CONTINUITY IS REQUIRED.
*
*	FIRST, THE REMAINING SECTORS IN THE GROUP ARE USED.
*	2ND, ACA ATTEMPTS TO OBTAIN THE IMMEDIATELY FOLLOWING GROUP.
*	3RD, ACA TRYS TO LOCATE A VIRGIN CLUSTER
*	4TH, ACA TAKES ANY FREE GROUPS.
*
*	ENTRY	(B) = SECTOR COUNT
*		AIO.XXX SETUP
*	EXIT	(B) = SECTORS NOT ALLOCATED
*		AIO.CNT = AMOUNT ALLOCATED
*		AIO.EOM = EC.EOM*2+1 IF END OF MEDIA
*		AIO.LGN, AIO.LST UPDATED FOR ADDITIONS
*		AIO,CGN, AIO.CSI = AIO.LGN, AIO.LSI
*		AIO.TFP = SETUP WITH GROUP AND INDEX OF START OF AREA
*	USES	ALL


ACA	MVI	C,0		(C) = COUNT ALLOCATED
ACA0	LHLD	AIO.LGN		(L) = AIO.LGN, (H) = AIO.LSI
	ERRNZ	AIO.LSI-AIO.LGN-1
	SHLD	AIO.TFP		SAVE WRITE ADDRESS

ACA1	LXI	H,AIO.LSI	(M) = LAST SECTOR INDEX
	LDA	AIO.SPG		(A) = SECTORS PER GROUP
	SUB	M		(A) = SECTORS LEFT IN GROUP
	JZ	ACA3		NONE LEFT
	CMP	B
	JC	ACA2		NOT TOO MANY IN GROUP FOR NEED
	MOV	A,B		DONT TAKE MORE THAN WE NEED
ACA2	MOV	D,A		(D) = AMOUNT IN GROUP
	ADD	M
	MOV	M,A		ADVANCE AIO.LSI
	MOV	A,D		(A) = AMOUNT ALLOCATED FROM GROUP
	ADD	C
	MOV	C,A		ADVANCE TOTAL ALLOCATED COUNT
	MOV	A,B
	SUB	D		DECREMENT NEEDED COUNT
	MOV	B,A
	JZ	ACA9		GOT ALL WE NEED

*	FINISHING THE GROUP WASENT ENOUGH. TRY TO GET THE FOLLOWING
*	GROUP.

ACA3	MVI	L,#AIO.LGN	(HL) = #AIO.LGN
.	SET	AIO.LGN/256
	ERRNZ	AIO.LSI/256-.	MUST BE IN SAME PAGE
	MOV	D,M		(D) = AIO.LGN
	INR	D		(D) = FOLLOWING GROUP #
	CALL	FFB		FIND FREE BLOCK
	JC	ACA8		END OF MEDIA
	JNZ	ACA9		COULDNT GET ONE CONTIGUOUS

*	GOT A BLOCK. CHAIN IT TO THE FILE

	CALL	CFF		CHAIN FREE BLOCK TO FILE
	MOV	A,C
	ANA	A
	JZ	ACA0		AM STILL LOOKING FOR THE START
	JMP	ACA1		GO SOME MORE


**	END OF MEDIA EXIT. FLAG EOM IF COULDNT ALLOCATE ANY

ACA8	MOV	A,C
	ANA	A
	JNZ	ACA9		GIVE HIM WHAT WE DID GET, ANYWAY...
	MVI	A,EC.EOM*2+1
	STA	AIO.EOM		SET EOM

**	NORMAL EXIT. (C) = AMOUNT ALLOCATED

ACA9	MOV	A,C
	STA	AIO.CNT		SET COUNT
	LHLD	AIO.LGN
	SHLD	AIO.CGN		UPDATE CURRENT=LAST
	ERRNZ	AIO.LSI-AIO.LGN-1
	ERRNZ	AIO.CSI-AIO.CGN-1
	RET
	SPACE	4,10
**	BND	- Boot New Disk					/2.0a/
*
*	BND boots a new disk when it is time to re-boot
*
*	ENTRY: 	NONE
*
*	EXIT:	To FATSERR if Error
*
*	USES:	ALL
*

BND	SCALL	.CLRCO		Cleary Type-Ahead
	CALL	$TYPTX
	DB	NL
	DB	'Install a bootable disk in SY0:.  Hit RETURN to reboot:'
	DB	' '+200Q

BND1	SCALL	.SCIN		Wait for a character
	JC	BND1
	CPI	NL		Wait for a Newline
	JNZ	BND1

BND.	XRA	A
	STA	AIO.UNI		Force Unit 0

BND2	MVI	A,DC.RDY
	CALL	SYDD
	JC	BND2		Wait for device to go ready

	LXI	H,0
	MVI	A,DC.MOU
	CALL	SYDD		Mount the possibly new volume
	CC	FATSERR

	LXI	B,DDF.BOL*256	BC = Boot Code Maximum Length
	LXI	D,SB.BOO	DE = Boot Code address
	LXI	H,DDF.BOO	HL = Boot SEctor
	MVI	A,DC.RER	Read Regardless
	CALL	SYDD
	CC	FATSERR

	LDA	SUNIT
	STA	AIO.UNI	Restore Physical Unit Number

*	Restore original vectors for old versions of HDOS		/2.0c/
	LXI	B,BOOTAL
	LXI	D,BOOTA
	LXI	H,D.CON
	CALL	$MOVE		Move the ROM vectors into RAM

	XRA	A		Clear Console
	OUT	SC.ACE+UR.IER
	OUT	SC.UART+USR
	RET
	SPACE	4,10
**	BTS	- Block to Sector				/80.06.gc/
*
*	Convert a block number to the corresponding sector
*	number.
*
*	ENTRY:	A	= Sectors Per Group
*		HL	= Block Number
*
*	EXIT:	HL	= Sector Number
*
*	USES:	HL
*

BTS	PUSH	PSW
	PUSH	D
	XCHG			DE = Block Number
	CALL	$MU86		HL = A * DE
	POP	D
	POP	PSW
	RET
	SPACE	4,10
**	CPA- CHECK FOR PENDING ABORT.
*
*	CPA IS CALLED WHEN A CONSOLE ABORT MAY BE PROCESSED.
*	IF THE SYSTEM IS READY, AND AN ABORT
*	IS PENDING, PROCESS IT.
*
*	CPA SHOULD BE CALLED WITH INTERRUPTS DISABLED, SO THAT
*	ANOTHER INTERRUPT CHARACTER CANNOT OCCUR DURING CPA PROCESSING.
*	THIS GUARANTEES THAT A USER PROGRAM WILL BE 'INTERRUPTED' WITH
*	THE PROGRAM COUNTER IN THE USER CODE, NEVER IN HDOS CODE.
*
*	UPON ENTRY TO THE USER INTERRUPT ROUTINE,
*
*	((SP)+0) = RETURN ADDRESS (IF USER WISHES TO RESUME NORMAL PROCESSING)
*	((SP)+2) = USER PSW
*	((SP)+4) = USER INTERRUPTED ADDRESS
*
*	THE USER REGISTER VALUES FOR B,C,D,E,H, AND L ARE STILL
*	IN THE REGISTERS.
*
*	ENTRY	((SP+0) = RETURN ADDRESS
*		((SP+2) = USER PSW
*		((SP+4) = USER INTERRUPTED ADDRESS
*	EXIT	TO *RED* IF NONE, OR DISABLED
*		TO PROCESSOR IF READY AND OK
*	USES	A,F



CPA	LDA	SYSMODE
	ANA	A
	RNZ			IN SYSCALL MODE

*	WILL ALLOW PROCESSING

	LDA	S.CAADR+1	(A) = HIGH BYTE ABORT ADDRESS
	ANA	A
	RZ			NO ABORT PENDING

*	HAVE ABORT. PROCESS IT

	PUSH	H
	LHLD	S.CAADR		(HL) = ADDRESS FOR JUMP
	XRA	A
	STA	S.CAADR+1	CLEAR
	INR	A		SET (A) <>.
	XTHL			RESTORE (HL), SET PROCESSOR
	EI
	RET			ENTER ROUTINE
	SPACE	4,10
**	FCI - FETCH CHANNEL INFORMATION.
*
*	FCI COPIES THE CHANNEL INFORMATION FROM THE
*	CHANNEL TABLE INTO THE ACTIVE I/O TABLE.
*
*	AIO.VEC = DRIVER ADDRESS
*	AIO.XXX SETUP IF DIRECTORY DEVICE
*	AIO.CTA = ADDRESS OF CHANNEL AREA
*
*	ENTRY	(A) = CHANNEL NUMBER
*	EXIT	(A) = CHANNEL STATUS BYTE
*		(HL) = ADDRESS OF FILE STATUS BYTE
*		'C' SET OF ERROR
*		 (A) = ERROR CODE
*	USES	A,F,H,L


FCI	LHLD	S.CFWA		(HL) = CHANNEL TABLE FWA
	ERRNZ	IOCCTD-1	CHANNEL 377Q IS FIRST IN LIST
	INR	A		(A) = INDEX OF CHANNEL IN CHANTAB
	PUSH	PSW		SAVE INDEX
FCI1	POP	PSW		(A) = INDEX
	ANA	A
	JZ	FCI2		GOT IT
	DCR	A		DECREMENT COUNT
	PUSH	PSW		SAVE INDEX
	MOV	A,M
	INX	H
	MOV	H,M
	MOV	L,A		FOLLOW LINK
	ORA	H
	JNZ	FCI1		MORE TO FOLLOW

*	CHANNEL DOES NOT EXIST. FLAG ERROR

	POP	PSW
	MVI	A,EC.ICN	ILLEGAL CHANNEL NUMBER
	STC
	RET

*	GOT CHANNEL

FCI2	PUSH	B
	PUSH	D		SAVE REGISTERS
	CALL	$INDLB		A  = UNIT CODE			/80.02.GC/
	DW	IOC.UNI						/80.02.GC/
	STA	AIO.UNI		INSURE UNIT SET UP FOR SEQ.	/80.02.GC/
	INX	H
	INX	H		MOVE PAST LINK
	ERRNZ	IOC.DDA-2	POINT TO DDA
	SHLD	AIO.CHA		SET BLOCK ADDRESS
	INX	H
	INX	H
	ERRNZ	IOC.FLG-IOC.DDA-2	(HL) = #IOC.DDA
	PUSH	H		SAVE ADDRESS
	MOV	A,M		(A) = TYPE
	ANI	FT.DD		SEE IF DIRECTORY TREE
	DCX	H
	DCX	H
	ERRNZ	IOC.DDA-IOC.FLG+2	(HL) = #IOC.DDA
	XCHG
	LXI	H,AIO.DDA
	LXI	B,IOC.SQL
	JZ	FCI3		IS SEQUENTIAL
	MVI	C,IOC.DIL	IS DIRECTORY
FCI3	CALL	$MOVE		MOVE DATA
	POP	H
	MOV	A,M		A = FLAG
	POP	D
	POP	B
	RET
	SPACE	4,10
**	GSP	GET SYSTEM POINTER
*
*	GET THE SYSTEM POINTER
*
*
*	ENTRY:	GSPA	= SY: device table entry address	/80.06.gc/
*
*	EXIT:	HL	= SYSTEM DEVICE UNIT POINTER
*
*	USES:	PSW,HL
*

GSP	LHLD	GSPA		HL = SY: device table entry	/80.06.gc/
	PUSH	D
	LXI	D,DEV.UNT	HL = POINTER TO UNIT TABLE POINTER
	DAD	D
	POP	D
	XRA	A						/80.05.gc/
*	LDA	SUNIT		A  = system Unit		/80.05.gc/
	JMP	GUP

GSPA	DW	0		Saved SY: device table entry	/80.06.gc/
	SPACE	4,10
**	LDD - LOAD DEVICE DRIVER.
*
*	LDD IS CALLED TO PERFORM THE SUSPENDED LOAD OF A DEVICE DRIVER.
*
*	IF SOME OVL CODE WISHES TO LOAD A DEVICE DRIVER, IT MUST
*	SUSPEND THE REQUEST, SINCE THE DEVICE DRIVER WILL OVERLAY THE
*	OVL CODE. AFTER THE OVL CODE EXITS, THE RESIDENT CODE WILL CALL
*	LDD TO PERFORM THE ACTUAL LOAD, OVER THE OVL.
*
*
*	This code has been modified to reduce the dependencies
*	on a cluster size of 2.  the GRT address and SPG are
*	not dynamically computed so that the mount of SY0: may
*	be kludged by pre-stuffing them.
*					G. Chandler	80.06.19
*
*
*	ENTRY	DD.IOC = POINTER TO IOC.DDA
*		DD.LDA = LOAD ADDRESS
*		DD.LEN = LOAD LENGTH
*		DD.GRP = SECTOR INDEX ON SYSTEM DEVICE
*		DD.DTA = DEV.RES ADDRESS
*		DD.OPE = OPEN CODE (DC.OPR, DC.OPW, DC.OPU)
*
*		LDD8A	= system GRT address			/80.06.GC/
*		LDD8B	= system SPG				/80.06.GC/
*
*	EXIT	OVL CODE DESTROYED
*	USES	NONE


LDD	CALL	$SAVALL		SAVE REGS

*	CLEAR OVL RESIDENT FLAG

	LXI	H,S.OVLFL
	MOV	A,M
	ANI	377Q-OVL.IN
	MOV	M,A		CLEAR IN FLAG

*	LOAD OVERLAY

	LDA	LDD8B		LDD8B = System SPG		/80.06.gc/
	ANI	376Q						/80.06.GC/
	RRC			A  = 512 byte reads/group	/80.06.gc/
	STA	LDD9B		Initialize Current Set Index	/80.06.gc/
	STA	LDD9A		Initialize Sets/group		/80.06.gc/
	LHLD	S.DDGRP						/80.06.GC/
	MVI	H,0		HL = driver group number	/80.06.gc/
	LDA	LDD8B		A  = SPG			/80.06.gc/
	CALL	BTS		HL = sector number		/80.06.gc/
	CALL	LDD9		ignore parameters		/80.06.gc/
	ERRNZ	DVD.ENT-2000A					/80.06.GC/
	SHLD	LDD8C		Safe it for later		/80.06.gc/

	LHLD	S.DDLEN		(HL) = LENGTH
	MOV	B,H
	MOV	C,L		(BC) = LENGTH
	LHLD	S.DDLDA		(HL) = LOAD ADDRESS
	PUSH	H		SAVE FOR LATER
	XCHG
	LXI	H,SECSCR+511	FORCE NEW DISK READ RIGHT AWAY

*	LOAD BINARY

LDD2	CALL	LDD8		FIND NEXT BYTE
	MOV	A,M		(A) = NEXT BYTE
	STAX	D		COPY
	INX	D
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	LDD2		MORE TO GO

*	CODE ALL LOADED. RELOCATE IT

	POP	B		(BC) = REL FACTOR
	DCR	B
	DCR	B
	ERRNZ	DVD.ENT-2000A	ASSUME DRIVER ENTRY = 2000A
LDD3	CALL	LDD8
	MOV	E,M
	CALL	LDD8
	MOV	D,M		(DE) = REL ADDRESS OF WORD TO RELOCATE
	MOV	A,D
	ORA	E
	JZ	LDD4		ALL DONE
	XCHG			(HL) = REL ADDRESS OF WORD TO RELOCATE
	DAD	B		(HL) = ABS ADDRESS OF WORD TO RELOCATE
	MOV	A,M
	ADD	C
	MOV	M,A
	INX	H
	MOV	A,M
	ADC	B
	MOV	M,A
	XCHG			RESTORE (HL)
	JMP	LDD3

*	SETUP ENTRY ADDRESSES IN TABLES

LDD4	EQU	32323A		USE WHATS IN ROM
PCHL	EQU	32361A		USE PCHL IN ROM
	SPACE	2,10
**	LDD8 - READ A BYTE FROM THE FILE.			/80.06.gc/
*
*	This code has been modified to read device drivers off of
*	system volumes with many differant SPG factors.  Unfortunately,
*	if a new volume is mounted, the system volume stuff will not
*	be updated.
*
*	If the sector pointer were not on an even boundary, or
*	the cluster factor were not a multiple of 2, this code
*	would not work well.  Therefore, it is up to INIT to
*	enforce even clusters.
*
*
*	ENTRY	(HL) = SECSCR POINTER OF CURRENT BYTE
*
*		LDD8A	= address of system device GRT		/80.06.gc/
*		LDD8B	= Sectors/Group on system volume	/80.06.gc/
*		LDD8C	= current sector number			/80.06.gc/
*		LDD9A and LDD9B as required by LDD9		/80.06.GC/
*
*	EXIT	(HL) = ADDRESS OF NEXT BYTE
*
*	USES	A,F,H,L
*

LDD8	INR	L		POINT TO NEXT BYTE
	RNZ			GOT IT

	INR	H		MAYBE IN NEXT GROUP
	PUSH	H						/79.11.GC/
	LXI	H,SECSCR+256					/79.11.GC/
	MOV	A,H						/79.11.GC/
	POP	H						/79.11.GC/
*	MVI	A,SECSCR+256/256				/79.11.GC/
	CMP	H
	RE			OK, IN SECOND SECTOR NOW

*	MUST READ ANOTHER

	PUSH	B
	PUSH	D
	LXI	D,SECSCR	DE = address
	LXI	B,512		(BC) = COUNT
	LHLD	LDD8C		HL = Sector Number		/80.06.GC/
	PUSH	D		SAVE #SECSCR			/80.06.GC/
	PUSH	H						/80.06.GC/
	CALL	S.READ		READ IT				/80.06.gc/
	POP	H		HL = sector number		/80.06.gc/
	CALL	LDD9						/80.06.gc/
	SHLD	LDD8C		Update Sector Number		/80.06.gc/
	POP	H		HL = SECSCR			/80.06.GC/
	POP	D		RESTORE (DE) AND (BC)
	POP	B
	RET

LDD8A	DW	0		System GRT address		/80.06.gc/
LDD8B	DB	0		System Sectors/Group		/80.06.gc/
LDD8C	DW	0		Current Sector Number		/80.06.gc/
	SPACE	4,10
**	LDD9							/80.06.GC/
*
*	LDD9 advances the current driver sector pointer
*	to the next multiple of 2 sectors.  Not this routine
*	will not work if the cluster is odd, or the *set*
*	code is not a multiple of 512.
*
*	ENTRY:	HL	= Current Sector Number
*		LDD8A, LDD8B, and LDD8C as required by LDD8
*		LDD9A	= 512 bytes reads per group
*		LDD9B	= read index current group
*
*	EXIT:	HL	= Next Sector Number
*
*	USES:	PSW,HL
*
.	SET	DVD.ENT/512*512
	ERRNZ	DVD.ENT-.		Must be a multiple of 512

LDD9	LDA	LDD9B
	DCR	A		Count these sectors
	STA	LDD9B
	JZ	LDD10		At the end of this group

*	More available sectors in this group

	INX	H
	INX	H
	RET

*	Need to find the next Group

LDD10	LDA	LDD9A
	STA	LDD9B		Reset Counter
	LDA	LDD8B		A  = SPG
	CALL	STB		HL = Block Number
	LDA	LDD8A+1
	MOV	H,A		HL = GRT address
	MOV	L,M		L  = Next Block Number
	MVI	H,0
	LDA	LDD8B		A  = SPG
	CALL	BTS		HL = sector Number
	RET
	
LDD9A	DB	0		Number of 512 byte reads per group
LDD9B	DB	0		Current read index
	SPACE	4,10
**	OTI	- OVERLAY TABLE INDEX
*
*	OTI COMPUTES THE OVERLAY TABLE INDEX ADDRESS BASED ON THE OVERLAY
*	INDEX, (AS DEFINED IN LOADO,) AND THE OFFSET INTO THE TABLE ENTRY.
*
*	USE:	CALL	OTI
*		DW	offset
*
*
*	ENTRY:	(A)	= OVERLAY INDEX
*
*	EXIT:	(HL)	= ADDRESS OF THE SPECIFIED TABLE ENTRY
*
*	USES:	(PSW),(HL)
*

OTI	ADD	A		(A) = 2*(A)
	ADD	A		(A) = 4*(A)
	ADD	A		(A) = 8*(A)
	ERRNZ	OVL.ENS-8
	LXI	H,OVLTAB	TABLE FIRST WORD ADDRESS
	CALL	$DADA.		(HL) = TABLE ENTRY ADDRESS
	XCHG
	XTHL			SAVE (DE)
	PUSH	D		SAVE TABLE ENTRY ADDRESS
	MOV	E,M
	INX	H
	MOV	D,M		(DE) = TABLE ENTRY OFFSET
	INX	H		(HL) = RETURN ADDRESS
	XTHL			(HL) = TABLE ENTRY ADDRESS
	DAD	D		(HL) = TABLE ENTRY OFFSET ADDRESS
	POP	D		(DE) = RETURN ADDRESS
	XCHG			(HL) = RETURN ADDRESS
	XTHL			(HL) = OLD (DE)
	XCHG			(HL) = TAB. ENTRY OFFSET ADDR, (DE = OLD (DE)
	RET
	SPACE	4,10
**	RRC - REMOVE REGULAR CHARACTER
*
*	RRC REMOVES THE LAST CHARACTER IN THE INPUT CIRCULAR BUFFER,
*	IF IT IS NOT A NEW-LINE CHARACTER (00).
*
*	ENTRY	NONE
*	EXIT	'Z' SET IF NO CHARACTERS, OR LAST ONE IS '00
*		'Z' CLEAR IF GOT CHARACTER
*		 (A) = CHARACTER
*	USES	A,F,H,L


RRC	LHLD	SCIIN
	LDA	SCIOUT
	CMP	L
	RE			NONE
	LDA	SCIFWA
	CMP	L
	JNE	RRC1		NOT AT BEGINNING
	LHLD	SCILWA
RRC1	DCX	H		DECREMENT POINTER
	MOV	A,M		(A) = VALUE
	CPI	NL
	RE     			IS END OF LINE
	CPI	CTLD
	RE			IS END OF FILE
	SHLD	SCIIN		UPDATE POINTER
	RET
	SPACE	4,10
**	SCI - STORE CHANNEL INFORMATION.
*
*	SCI SAVES THE ACTIVE CHANNEL INFORMATION BACK
*	INTO THE CHANNEL BLOCK.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	NONE


SCI	CALL	$SAVALL
	LHLD	AIO.CHA
	ERRNZ	IOC.FLG-IOC.DDA-2
	INX	H
	INX	H		(HL) = IOB.FLG ADDRESS
	LXI	B,IOC.DRL	(BC) = LEN
	LXI	D,AIO.FLG
	CALL	$MOVE		MOVE DATA
	JMP	$RSTALL		RESTORE ALL REGS
	SPACE	4,10
**	SDD - STAND-IN DEVICE DRIVER.
*
*	SDD IS SETUP AS THE DEVICE DRIVER ADDRESS FOR DRIVERS WHICH
*	ARE NOT IN MEMROY. IF THE REQUEST IS AN OPEN, POSTPONE IT
*	UNTIL 'LDD' LOADS THE OVERLAY. OTHERWISE, IS A FATAL
*	SYSTEM ERROR.
*
*	ENTRY	(A) = CODE
*	EXIT	NONE
*	USES	A,F	


SDD	CPI	DC.LOD		check for load			/80.04.gc/
	JZ	SDD1						/80.04.gc/

	CPI	DC.OPR
	CC	FATSERR
	CPI	DC.OPU+1
	CNC	FATSERR
	
SDD1	STA	S.DDOPC		SET CODE			/80.04.gc/
	RET
	SPACE	4,10
**	STB	- Sector to Block				/80.06.gc/
*
*	STB converts a sector number to the corresponding
*	block number
*
*	ENTRY:	A	= Sectors Per Group
*		HL	= Sector Number
*
*	EXIT:	HL	= Block Number
*
*	USES:	HL
*

STB	PUSH	PSW
	PUSH	B
	PUSH	D
	MOV	B,H
	MOV	C,L		BC = sector number
	MVI	D,0
	MOV	E,A		DE = sectors/group
	CALL	$DU66		HL = BC / DE
	POP	D
	POP	B
	POP	PSW
	RET
	STL	'COMMON DECKS'
	EJECT
	XTEXT	TBRA
	XTEXT	GUP
	XTEXT	HLCPDE
	XTEXT	HLIHL
	XTEXT	ILDEHL
	XTEXT	INDL
	XTEXT	INDXX
	XTEXT	ISDEHL
	XTEXT 	MOVE
	XTEXT	DADA2
	XTEXT	SAVALL
	XTEXT	COMP
	XTEXT	XCHGBC
	XTEXT	ZERO
	XTEXT	WER
	XTEXT	CHL
	STL	'REPLACEMENTS FOR H17 ROM'
	EJECT
**	THE FOLLOWING ROUTINES ARE REPLACEMENTS FOR THE H17 ROM CODE.
	SPACE	4
**	ISY	- Internal SY Device Driver
*
*	ISY maps the logical system device units into the real
*	physical units known by the driver.  This is done so
*	that any device may be booted.
*
*	ENTRY:	NONE
*
*	EXIT:	NONE
*
*	USES:	NONE
*
	
ISY	PUSH	H
	LXI	H,AIO.UNI
	MOV	H,M
	XTHL			Save current device specification

	PUSH	PSW
	PUSH	D
	PUSH	H

	LHLD	GSPA
	CALL	$INDLB
	DW	DEV.MNU
	MOV	D,A		D = max num of units

	LDA	AIO.UNI
	LHLD	SUNIT
	ADD	L		A = AIO.UNI+SUNIT

	SUB	D
	JNC	ISY1
	ADD	D		A = A mod D
ISY1	EQU	*

	STA	AIO.UNI

	POP	H
	POP	D
	POP	PSW

	PUSH	H
	LXI	H,ISY2
	XTHL			Set up RETurn address
	PUSH	H
	LHLD	MSYDD
	XTHL			Set up Driver address on Stack
	RET			Call Driver

ISY2	XTHL
	PUSH	PSW
	MOV	A,H
	STA	AIO.UNI		Replace the original value
	POP	PSW
	POP	H		Restore exit HL
	RET
	STL	'RESIDENT DEVICE DRIVERS'
	EJECT
***	TTDVD - RESIDENT TT DEVICE DRIVER.*


TTDVD	EQU	*
	CALL	$TBRA
	
TTDVD0	DB	TTREAD-*	READ
	DB	TTWRITE-*	WRITE
	DB	TTABT-*		READR
	DB	TTOPE-*		OPENR
	DB	TTOPE-*		OPENW
	DB	TTABT-*		OPENU
	DB	TTNOP-*		CLOSE
	DB	TTNOP-*		ABORT
	DB	TTABT-*		MOUNT
	DB	TTNOP-*		LOAD				/80.04.GC/
	DB	TTNOP-*		Ready				/80.06.gc/
	ERRNZ	*-TTDVD0-DC.MAX	Handle ALL requests		/80.06.gc/
	
TTABT	MVI	A,EC.DDA	DEVICE DRIVER ABORT
	STC
	RET

TTOPE	LDA	S.CONFL
	ANI	377Q-CO.FLG		CLEAR CTL-O
	STA	S.CONFL
*	LDA	S.CSLMD						/79.02.04.GC/
*	ANI	CSL.ECH		PRESERVE ECHO BIT		/79.02.04.GC/
*	ORI	CSL.WRP		SET WRAP MODE			/79.02.04.GC/
*	MVI	A,CSL.WRP					/79.02.GC/
*	STA	S.CSLMD		SET WRAP MODE			/79.04.GC/
	XRA	A
	STA	EOFFLG		CLEAR EOF ON INPUT FLAG
	RET

TTNOP	ANA	A
	RET			DO NOTHING
	SPACE	3,10
**	TTREAD - READ
*

TTR2	STAX	D		STORE CHAR
	INX	D
	DCX	B
	
TTREAD	EQU	*
	LDA	EOFFLG
	RAR
	RC			IS EOF

	MOV	A,B
	ORA	C
	RZ			ALL DONE

*	TAKE  A CHAR

TTR1	LDA	S.CAADR+1
	ANA	A
	JNZ	TTREOF
	SCALL	.SCIN						/80.06.GC/
	JC	TTR1		WAIT TILL GOTIT
	CPI	CTLD						/80.06.GC/
	JNE	TTR2		NOT CTL-D

*	HAVE EOF CHARACTER. FILL THIS SECTOR WITH 0'S

TTREOF	MVI	A,EC.EOF*2+1
	STA	EOFFLG		FLAG EOF
TTR4	XRA	A
	STAX	D		STORE 0
	INX	D
	DCX	B
	MOV	A,C
	ORA	C
	JNZ	TTR4
	MVI	A,EC.EOF
	STC
	RET


EOFFLG	DB	0		EOF FLAG
	SPACE	4,10
TTWRITE LDA	S.CAADR+1
	ANA	A
	RNZ			ALL DONE
	MOV	A,B
	ORA	C
	RZ			ALL DONE
	LDAX	D
	ANA	A
	JZ	TTW2		NULL CHARACTER
	SCALL	.SCOUT						/80.06.GC/
TTW2	INX	D
	DCX	B
	JMP	TTWRITE
	STL	'DATA AREAS'
	EJECT
**	RELOCATABLE RAM CELLS.
*
*	THESE CELLS RESIDE AT THE TOP OF THE MONITOR.

	SPACE	3
**	TABLE OF OVERLAY DATA
*
*	THIS TABLE IS GENERATED AT BOOT-UP TIME
*


OVLCNT	EQU	2

OVLTAB	EQU	*

	DS	OVL.ENS 		OVERLAY *HDOSOVL .SYS*
	
	DS	OVL.ENS			OVERLAY *HDOSOVL2.SYS*

OVLMAX	EQU	*-OVLTAB/OVL.ENS

	ERRMI	OVLMAX-OVLCNT
	SPACE	3,10
**	DEVICE LIST

DEVCNT	EQU	7		INITIALLY 7 DEVICES

DEVLST	DS	0		DEVICE TABLE
	SPACE	4,10
TTDEV	DS	0		TT DEVICE TABLE ENTRY
	ERRNZ	*-TTDEV-DEV.NAM
	DB	'TT'		DEVICE NAME
	ERRNZ	*-TTDEV-DEV.RES
	DB	DR.IM+DR.PR	PERMENANTLY RESIDENT
	ERRNZ	*-TTDEV-DEV.JMP
	DB	303Q		JUMP OPCODE
	ERRNZ	*-TTDEV-DEV.DDA
	DW	TTDVD		DRIVER ADDRESS
	ERRNZ	*-TTDEV-DEV.FLG
	DB	DT.CR+DT.CW
	ERRNZ	*-TTDEV-DEV.MUM
	DB	1		MOUNTED MASK
	ERRNZ	*-TTDEV-DEV.MNU
	DB	1		MAXIMUM NUMBER OF UNITS
	ERRNZ	*-TTDEV-DEV.UNT
	DW	TTOUNT		UNIT TABLE
	ERRNZ	*-TTDEV-DEV.DVL
	DW	0		DRIVER LENGTH
	ERRNZ	*-TTDEV-DEV.DVG
	DB	0		DRIVER GROUP NUMBER
	ERRNZ	*-TTDEV-DEVELEN
	SPACE	4,10
	DB	0		NO MORE DEVICES
	DS	DEVCNT-1*DEVELEN	ROOM FOR 5 MORE DEVICES
	DB	0		BYTE USED IF LAST DEVLST ENTRY USED
	SPACE	4,10
TTOUNT	DS	0

	ERRNZ	UNT.FLG-0
	DB	DT.CR+DT.CW		TT0:
	DS	UNT.SIZ-1
	SPACE	4,10
**	INITIAL CHANNEL TABLE.
	
CHANCNT EQU	6		6 CHANNELS

CHANTAB EQU	*

*	NOTE THAT THE FIRST CHANNEL IS CHANNEL 377Q, WHICH IS THE
*	OVERLAY CHANNEL. THE .CLEARA FUNCTION ASSUMES THIS, AS
*	DOES FCI.

	DW	*+IOCELEN	LINK - CHANNEL 377
	DB	0,0,0
	ERRNZ	IOCCTD-1	USER CHANNEL #0 FOLLOWS
	DS	IOCELEN-5
	DW	*+IOCELEN	LINK - CHANNEL 0
	DB	0,0,0
	DS	IOCELEN-5
	DW	*+IOCELEN	LINK - CHANNEL 1
	DB	0,0,0
	DS	IOCELEN-5
	DW	*+IOCELEN	LINK - CHANNEL 2
	DB	0,0,0
	DS	IOCELEN-5
	DW	*+IOCELEN	LINK - CHANNEL 3
	DB	0,0,0
	DS	IOCELEN-5
	DW	*+IOCELEN	LINK - CHANNEL 4
	DB	0,0,0
	DS	IOCELEN-5
	DW	0		NULL LINK - CHANNEL 5
	DB	0,0,0
	DS	IOCELEN-5

*	OVL LOAD ADDRESS

HIGHDAT EQU	*


**	SYSTEM MODE. NON-ZERO WHEN PROCESSING SYSCALL.

	ERRNZ	*-HIGHDAT-M.SYSM
SYSMODE DB	0

	ERRNZ	*-HIGHDAT-M.SALO
SALONE	DB	0		STAND ALONE FLAG != 0 => CAN GO STAND ALONE

	ERRNZ	*-HIGHDAT-M.CSLC
CSLLCNT DB	0		LINES ENTERED IN BUFFER
	ERRNZ	*-HIGHDAT-M.CPRE
SCIPRE	DB	0		PREVIOUSLY INPUT CHARACTER
	ERRNZ	*-HIGHDAT-M.CRUB
CSLRBF	DB	0		RUBOUT FLAG

CC.FLG	EQU	00000011B	CTL CHARACTERS FLAG
CZ.FLG	EQU	00001000B	CTL-Z FLAG
	ERRNZ	*-HIGHDAT-M.CINT
SCINTFL DB	0		SYSTEM CONSOLE INTERRUPT FLAGS

	ERRNZ	*-HIGHDAT-M.CIN
SCIIN	DW	CSLIBUF		IN POINTER
	ERRNZ	*-HIGHDAT-M.COUT
SCIOUT	DW	CSLIBUF		OUT POINTER
	ERRNZ	*-HIGHDAT-M.CFWA
SCIFWA	DW	CSLIBUF
	ERRNZ	*-HIGHDAT-M.CLWA
SCILWA	DW	CSLIBFE		END POINTER

	ERRNZ	*-HIGHDAT-M.CDLY
CSLDLY	DB	4		PAD CHARACTER COUNT
	ERRNZ	*-HIGHDAT-M.CDCA
CSLDCA	DW	SCOUTA		ADDRESS OF DELAY CHARACTER

	ERRNZ	*-HIGHDAT-M.SUNI				/80.05.gc/
SUNIT	DB	0		System Unit Number		/80.05.gc/
	ERRNZ	*-HIGHDAT-M.SYDD					/2.0a/
MSYDD	DW	0		System Device Driver			/2.0a/

CSLIBUF DS	101
CSLIBFE DS	0		END OF BUFFER

*	PATCH AREA

	DB	377Q-'B',377Q-'Y',377Q-' ',377Q-'G',377Q-'A',377Q-'C',377Q-' '
	DB	377Q-'I',377Q-'N',377Q-' ',377Q-'R',377Q-'E',377Q-'M',377Q-'E'
	DB	377Q-'M',377Q-'B',377Q-'R',377Q-'A',377Q-'N',377Q-'C',377Q-'E'
	DB	377Q-' ',377Q-'O',377Q-'F',377Q-' ',377Q-'J',377Q-'G',377Q-'L'
	DB	FF

SECSCR	EQU	*		SYSTEM SCRATCH AREA
	DS	512

LWASYS	EQU	*		END OF MONITOR
LENSYS	EQU	LWASYS-FWASYS

*	PATCH AREA FOR RELOCATION TABLE

	DS	16

	
	
	LON	G
	LON	C
	END
