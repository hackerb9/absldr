* * *	MFDVD contains the mini-floppy device driver ROM
*	modifications.  If SET symbol MFBOOT is 1, only the
*	code necessary for the boot track is generated.
 
*	Copyright 1981 UltiMeth Corp.
	SPACE	3
R.MOUNT	EQU	33345A
R.ABORT	EQU	33366A
R.XOK	EQU	33374A
R.XIT	EQU	33375A
R.READ	EQU	34077A
R.READR	EQU	34321A
R.WRITE	EQU	34336A
R.CDE	EQU	35136A
R.DTS	EQU	35172A
R.SDT	EQU	35225A
R.MAI	EQU	35251A
R.MAO	EQU	35254A
R.LPS	EQU	35321A
R.RDB	EQU	36044A
R.SDP	EQU	36062A
R.STS	EQU	36165A
R.STZ	EQU	36254A
R.ERRT	EQU	37150A
	SPACE	3
VFL.2SD	EQU	00000001B	;2-SIDED DISK DRIVE/MEDIA
VFL.80T	EQU	00000010B	;80-TRACK/SIDE DISK DRIVE/MEDIA
	SPACE	6
* *	MFDVD initializes the mini-floppy jump vector in RAM
 
MFDVD	LXI	BC,BOOTAL
	LXI	DE,BOOTA
	LXI	HL,D.CON
	CALL	$MOVE		;MOVE ROM CONSTANTS/VECTORS TO RAM
 
	LXI	BC,MFVECSZ	;GET REPLACEMENT VECTOR SIZE
	LXI	DE,MFVECTR	;GET REPLACEMENT VECTOR LOC
	LXI	HL,D.MOUNT	;GET DESTINATION VECTOR LOC
	CALL	$MOVE		;MOVE IN REPLACEMENT VECTOR COMPONENT
 
	XRA	A
	CALL	MFDVSEL		;RESET DISK UNITS
 
	XRA	A
	OUT	UP.FC		;SET FILL CHARACTER
 
	LHLD	MFIDLET
	SHLD	D.XITA		;SET IDLE TIMEOUT VALUES FOR MOTOR, SELECT
	MOV	H,A
	SHLD	D.DLYMO		;SET MOTOR, RESET SELECT TIMEOUT COUNTS
 
	LHLD	MFIODLY
	SHLD	D.SDPA		;SET I/O DELAY VALUES
 
	LXI	HL,MFCLOCK
	SHLD	.UIVEC+1	;SET REPLACEMENT CLOCK ROUTINE
 
	IF	MFBOOT-1
 
	STA	.CTL2FL		;INITIALIZE PORT BITS IF NOT MTR-89 ROM
 
	ELSE
 
	LXI	HL,0
	SHLD	D.ERTS		;CLEAR ERROR TRACK/SECTOR NUMBER
 
	LXI	HL,MFERR
	SHLD	D.ERRT+1	;ERROR TRAP ROUTINE
 
	ENDIF
 
	RET			RETURN
	SPACE	3
* *	MFSDP generates the correct disk select bits, and 
*	performs initialization.
*
*	The  "LXI  HL,MFUTBL"  instruction must be first to
*	allow other routines to simply locate  "MFUTBL".
 
MFSDP	LXI	HL,MFUTBL	;GET UNIT TABLE LOC
	MVI	A,MFERCNT
	STA	D.OECNT		;SET OPERATION MAX ERROR COUNT
	STA	MFFERR		;SET FIRST ERROR FLAG
	LDA	AIO.UNI
	PUSH	PSW		;SAVE UNIT
	ADD	A		;GET UNIT TABLE OFFSET
	CALL	$DADA		;GET UNIT ENTRY LOC
	SHLD	MFUENT		;SAVE UNIT ENTRY LOC
	INX	HL		;GET SEEK STEP TIME LOC
	MOV	A,M		;GET UNIT SEEK STEP TIME
	STA	D.MAIA		;SET SEEK STEP TIME
	POP	PSW		;RESTORE UNIT
	PUSH	PSW		;SAVE UNIT
	ADI	-2
	ACI	2+1		;NOW 0,1,2 GIVES 1,2,4
	ADD	A		;GENERATE UNIT BITS 2,4,8
	DI
	CALL	MFDVSEL		;GO SELECT DEVICE, RETURN DEVICE DIFFERENCE
	INX	HL		;GET IDLE MOTOR TIMEOUT COUNT LOC
	MVI	M,0		;RESET IDLE MOTOR TIMEOUT COUNT
	INX	HL		;GET IDLE SELECT TIMEOUT COUNT LOC
	JZ	MFSDPS1		;DEVICE STILL SELECTED, SKIP
 
	ANI	DF.MO		;WAS MOTOR PREVIOUSLY ON -
	LDA	D.SDPA		;GET MOTOR ON I/O DELAY VALUE
	JZ	MFSDPS1		;- YES, SKIP
 
	LDA	D.SDPB		;GET MOTOR OFF I/O DELAY VALUE
 
MFSDPS1	MOV	M,A		;SET I/O DELAY COUNT
 
	IF	MFBOOT-1
 
	LXI	HL,MFCLOCK
	SHLD	.UIVEC+1	;OVERWRITE INIT PROGRAM RESET
 
	ENDIF
 
	JMP	R.SDP+63A	;CONTINUE
	SPACE	3
* *	MFABORT is copied here so that it will enter the replacement
*	code for MFXOK - - the ROM code fell directly into the
*	ROM entry point for MFXOK.
 
MFABORT	CALL	D.SDP
	CALL	D.STZ
*	JMP	D.XOK
	ERRNZ	*-MFXOK
	SPACE	3
* *	MFXOK / MFXIT process select and motor timeout values.
 
MFXOK	XRA	A		;SET NO ERROR
 
MFXIT	PUSH	PSW
 
MFXITL1	LDA	D.DLYHS		;GET HEAD LOAD DELAY
	ANA	A		;HEAD FULLY LOADED -
	JNZ	MFXITL1		;- NO, LOOP
 
	LHLD	D.XITA		;GET IDLE TIMEOUT VALUES
	SHLD	D.DLYMO		;SAVE TIMEOUT COUNTS
	CALL	MFTMOUT		;GO PROCESS INITIAL TIMEOUT VALUES
	POP	PSW
	EI
	RET			;RETURN
	SPACE	3
* *	MFCLOCK handles head load timing and motor and select timeouts.
 
MFCLOCK	LDA	.TICCNT
	RRC			;EVEN CLOCK TICK -
	RC			;- NO RETURN
 
*	JMP	MFTMOUT		;GO PROCESS HEAD LOAD/SELECT & MOTOR TIMEOUTS
	ERRNZ	*-MFTMOUT
	SPACE	3
* *	MFTMOUT processes and decrements the head load delay, select
*	time-out, and motor time-out counters.
 
MFTMOUT	XRA	A
	LXI	HL,D.DLYHS	;GET HEAD LOAD/SELECT TIMEOUT COUNT LOC
	CMP	M		;HEAD LOADED/SELECT TIMED OUT -
	JNZ	MFTMOS1		;- NO, GO PROCESS SELECT TIMEOUT
 
	DCX	HL		;GET MOTOR ON TIMEOUT COUNT LOC
	CMP	M		;MOTOR TIMED OUT -
	RZ			;- YES, RETURN
 
	LDA	.TICCNT
	ANA	A		;DECREMENT MOTOR TIMEOUT COUNT -
	RNZ			;- NO, RETURN
 
	DCR	M		;DECREMENT MOTOR TIMEOUT COUNT
	RNZ			;MOTOR NOT TIMED OUT, RETURN
 
	JMP	MFDVOUT		;GO RESET DISK MOTORS
 
MFTMOS1	DCR	M		;DECREMENT HEAD LOAD/SELECT TIMEOUT COUNT
	RNZ			;RESULT NOT ZERO, RETURN
 
	DCX	HL		;SET MOTOR ON TIMEOUT COUNT LOC
	CMP	M		;MOTOR TIMEOUT IN EFFECT (DISK IDLE) -
	RZ			;- NO, RETURN
 
*	JMP	MFDVSEL		;GO DESELECT
	ERRNZ	*-MFDVSEL
	SPACE	3
* *	MFDVSEL / MFDVOUT provide a common means of selecting or
*	deselecting the disk units.
 
MFDVSEL	ORI	DF.MO		;SET MOTOR ON
 
MFDVOUT	LXI	HL,D.DVCTL	;GET DEVICE BITS LOC
	XRA	M		;GET DEVICE BITS DIFFERENCE
	ANI	-1-DF.WR	;MASK OUT WRITE ENABLE BIT
	PUSH	PSW		;SAVE DEVICE BITS DIFFERENCE
	XRA	M		;GET NEW DEVICE BITS W/ RAM WRITE ENABLE BIT
	MOV	M,A		;SAVE NEW DEVICE BITS
	OUT	DP.DC		;SELECT DISK
	POP	PSW		;RESTORE DEVICE BITS DIFFERENCE
	RET			;RETURN
	SPACE	3
* *	MFSTZ increases the operation seek step time by 2 ms on each
*	entry, and forces a reentry if track zero is not detected
*	after 79 seek steps.
 
MFSTZ	LHLD	D.TRKPT		;GET CURRENT TRACK NUMBER LOC
	MVI	M,0		;RESET CURRENT TRACK
	LXI	HL,D.MAIA	;GET SEEK STEP TIME LOC
	INR	M		;INCREASE STEP TIME INTERVAL
	MVI	L,80		;GET MAX NUMBER OF TRACKS
 
MFSTZLP	IN	DP.DC		;GET DISK UNIT STATUS
	ANI	DF.T0		;TRACK ZERO -
	RNZ			;- YES, RETURN
 
	DCR	L		;STEPPED ACROSS ENTIRE DISK -
	JZ	MFSTZ		;- YES, INCREASE STEP INTERVAL
 
	CALL	D.MAO		;STEP TOWARDS TRACK ZERO
	JMP	MFSTZLP		;GO TEST FOR TRACK ZERO
	SPACE	3
* *	MFDTS is copied here so that it will enter the replacement
*	code for MFSDT - - the ROM code branched directly to the
*	ROM entry point for MFSDT.
 
MFDTS	PUSH	BC
	LXI	BC,-10		;SET SECTORS PER TRACK
	MOV	A,B		;SET (A) = -1
 
MFDTSLP	INR	A		;COUNT EACH TRACK
	DAD	BC		;SUBTRACT ONE TRACK WORTH OF SECTORS
	JC	MFDTSLP		;CONTINUE IF REMAINING SECTORS POSITIVE
 
	STA	D.TT		;SAVE TRACK NUMBER
	MOV	A,L		;GET (SECTOR NUMBER) MINUS (SECTORS PER TRACK)
	SUB	C		;COMPUTE SECTOR NUMBER
	STA	D.TS		;SAVE SECTOR NUMBER
	POP	BC
*	JMP	D.SDT		;GO SEEK TRACK
	ERRNZ	*-MFSDT
	SPACE	3
* *	MFSDT delays on the current track long enough for any
*	write/tunnel erase to complete, and then seeks to the
*	desired track.
*
*	Also, this new code checks the unit/media for double-sided
*	capability and 40/80-track compatibility, and determines
*	the hardware side and track accordingly.
*
*	The  "LXI  HL,MFUENT"  instruction must be first to allow
*	other routines to simply locate  "MFUENT".
 
MFSDT	LHLD	MFUENT		;GET UNIT/MEDIA ENTRY LOC
	MVI	A,H17SDL	;TUNNEL ERASE DELAY
	CALL	D.UDLY
	MOV	A,M		;GET UNIT/MEDIA BITS
	ANI	VFL.2SD		;TWO SIDES (CLEAR CARRY) -
	LDA	D.TT		;GET TRACK ID
	JZ	MFSDTSK		;- NO, SKIP
 
	RAR			;- YES, GET TRACK NUMBER AND SIDE BIT
 
MFSDTSK	PUSH	PSW		;SAVE TRACK NUMBER
	SBB	A		;SET ALL ONES IF CARRY
	STA	MFSIDE		;SAVE SIDE INDICATION
	MOV	A,M		;GET UNIT/MEDIA BITS
	ANI	VFL.80T*10001B	;GET 40/80-TRACK UNIT/MEDIA BITS
	XRI	VFL.80T*10000B	;COMPATIBILITY MODE -
	JNZ	MFSDTLP		;- NO, SKIP
 
	POP	PSW		;GET TRACK NUMBER
	ADD	A		;DOUBLE TRACK NUMBER
	PUSH	PSW		;SAVE TRACK NUMBER
 
MFSDTLP	POP	PSW		;RESTORE NEW TRACK NUMBER
	LHLD	D.TRKPT		;GET OLD TRACK NUMBER LOC
	CMP	M		;SAME TRACK NUMBER
	JZ	D.STS		;- YES, SKIP SECTOR AND RETURN
 
	PUSH	PSW		;SAVE NEW TRACK NUMBER
	PUSH	HL		;SAVE OLD TRACK NUMBER LOC
	LXI	HL,MFSDTLP	;GET SEEK RETURN / LOOP LOC
	XTHL			;SAVE RETURN LOC, RESTORE OLD TRACK NUMBER LOC
	INR	M		;INCREMENT OLD TRACK NUMBER
	JNC	D.MAI		;MOVE ARM IN (INCREASE TRACK NUMBER)
 
	DCR	M
	DCR	M		;DECREMENT OLD TRACK NUMBER
	JMP	D.MAO		;MOVE ARM OUT (DECREASE TRACK NUMBER)
	SPACE	3
* *	MFSTS selects the proper side before returning.
 
MFSTS	CALL	R.STS
	LDA	MFSIDE		;GET SIDE INDICATION
	LHLD	.CTL2FL		;GET GENERAL PORT BITS
	XRA	L
	ANI	CB2.SID
	XRA	L		;REPLACE SIDE INDICATION IN PORT BITS
	ANI	-1-CB2.SSI	;RESET ANY UNWANTED BITS
	ORI	CB2.CLI		;KEEP CLOCK ENABLED
	OUT	OP2.CTL		;SELECT PROPER SIDE
	RET			;RETURN
	SPACE	3
* *	MFREAD circumvents a ROM bug which caused a direct return
*	to the location in the top of the stack prior to the call
*	when register BC (the byte count) is initially zero.
 
MFREAD	CALL	R.READ		;GO READ
	RET			;NORMALLY RETURN FROM HERE
	SPACE	3
* *	MFREADR circumvents a ROM bug which caused a direct return
*	to the location in the top of the stack prior to the call
*	when register BC (the byte count) is initially zero.
 
MFREADR	CALL	R.READR		;GO READ
	RET			;NORMALLY RETURN FROM HERE
	SPACE	3
* *	MFMOUNT mounts a floppy disk.  It reads the label sector
*	(separate from any HDOS label read) and obtains media
*	(volume) dependent data.
 
MFMOUNT	CALL	R.MOUNT		;GO MOUNT DISK (AND SET VOLUME ID)
	RC			;RETURN ON ERROR
 
	LXI	BC,LAB.VFL+1	;GET READ LENGTH
	LXI	DE,MFLABEL	;GET READ AREA LOC
	LXI	HL,9		;SET TO READ LABEL SECTOR
	CALL	D.READR		;GO READ PART OF LABEL
	RC			;RETURN ON ERROR
 
	LHLD	MFUENT		;GET UNIT/MEDIA ENTRY LOC
	LDA	MFLABEL+LAB.VFL  ;GET MEDIA FLAGS
	XRA	M
	ANI	VFL.80T+VFL.2SD
	XRA	M
	MOV	M,A		;UPDATE MEDIA INFO IN UNIT/MEDIA TABLE
	RRC
	RRC
	RRC
	RRC			;SHIFT UNIT INFO TO MEDIA INFO POSITION
	ANA	M
	XRA	M
	ANI	VFL.80T+VFL.2SD  ;NON-ZERO BITS INDICATE INCOMPATIBLE MEDIA
	RZ			;RETURN IF COMPATIBLE
 
	MVI	A,EC.DNS	;SET DEVICE NOT SUITABLE
	STC			;SET ERROR INDICATION
	RET			;RETURN
	SPACE	3
	IF	MFBOOT-1
 
MFWRITE	EQU	R.WRITE
MFCDE	EQU	R.CDE
MFERR	EQU	R.ERRT
 
	ELSE
 
* *	MFWRITE checks the logical and physical write protect status,
*	and returns if the write byte count is zero.
 
MFWRITE	PUSH	HL		;SAVE BLOCK NUMBER
	CALL	D.SDP		;SET DEVICE PARAMETERS
	LHLD	D.OPW
	INX	HL
	SHLD	D.OPW		;COUNT OPERATION
	IN	DP.DC
	ANI	DF.WP		;IS DISK WRITE PROTECTED -
	STC
	MVI	A,EC.WP
	JNZ	MFWRXIT		;- YES, EXIT
 
	LHLD	MFUENT		;GET UNIT/MEDIA ENTRY LOC
	MOV	A,M		;GET UNIT/MEDIA BITS
	ANI	VFL.80T*10001B	;GET 40/80-TRACK UNIT/MEDIA BITS
	XRI	VFL.80T*10000B	;COMPATIBILITY MODE -
	STC
	MVI	A,EC.WP
	JZ	MFWRXIT		;- YES, SIMULATE WRITE PROTECTED DISK
 
	XRA	A		;CLEAR CARRY
	DCX	BC
	INR	B
	JNZ	R.WRITE+32A	;NON-NULL LENGTH, GO WRITE
 
MFWRXIT	POP	HL
	JMP	D.XIT		;DO NOT WRITE, PERFORM EXIT PROCESSING
	SPACE	3
* *	MFCDE counts disk errors.  If this operation has 10 soft
*	errors, a hard error is recorded.
 
MFCDE	EI
	CALL	D.STZ		;SEEK TRACK ZERO
	CALL	D.SDT		;SEEK DESIRED TRACK
	CALL	MFSFERR		;GO INDICATE A SOFT ERROR
	LXI	HL,D.OECNT	;GET OPERATION ERROR COUNT LOC
	DCR	M
	RP			;NOT TOO MANY
 
	LHLD	D.SECNT
	DCX	HL		;RESET SOFT ERROR COUNT
	SHLD	D.SECNT
	LXI	HL,D.HECNT
	INR	M		;COUNT HARD ERROR
	LHLD	D.TT
	SHLD	D.ERTS		;RECORD ERROR TRACK AND SECTOR
	STC			;SET ERROR INDICATION
	RET			;RETURN
	SPACE	3
* *	MFERR records/counts low-level disk errors.
 
MFERR	INR	M		;COUNT ERROR
 
MFSFERR	LXI	HL,MFFERR	;GET FIRST ERROR FLAG LOC
	XRA	A
	CMP	M		;FIRST ERROR FOR THIS OPERATION -
	RZ			;- NO, RETURN
 
	MOV	M,A		;RESET FIRST ERROR FLAG
	LHLD	D.SECNT
	INX	HL		;UPDATE SOFT ERROR COUNT
	SHLD	D.SECNT
	RET
 
	ENDIF
	SPACE	3
MFLABEL	DS	0		;USE INITIAL JUMP VECTOR AREA FOR LABEL BUFFER
 
MFVECTR	JMP	MFMOUNT
	JMP	MFXOK
	JMP	MFABORT
	JMP	MFXIT
	JMP	MFREAD
	JMP	MFREADR
	JMP	MFWRITE
	JMP	MFCDE
	JMP	MFDTS
	JMP	MFSDT
	JMP	R.MAI
	JMP	R.MAO
	JMP	R.LPS
	JMP	R.RDB
	JMP	MFSDP
	JMP	MFSTS
	JMP	MFSTZ
 
MFVECSZ	EQU	*-MFVECTR
 
	ERRNZ	D.STZ+3-D.MOUNT-MFVECSZ
 
	IF	LAB.VFL+1-MFVECSZ/8000H  ;IF  LAB.VFL+1 > MFVECSZ
 
	DS	LAB.VFL+1-MFVECSZ
 
	ENDIF
	SPACE	3
MFFERR	DB	0		;FIRST ERROR FLAG
 
MFSIDE	DB	0		;SIDE INDICATION
 
MFUENT	DW	0		;CURRENT MFUTBL ENTRY LOC
 
MFUTBL	DB	MFU0TYP,MFU0SEK+1/2
	DB	MFU1TYP,MFU1SEK+1/2
	DB	MFU2TYP,MFU2SEK+1/2
 
MFIDLET	DB	MFMIDLE*2+1,MFSIDLE+3/4+1
 
MFIODLY	DB	MFONDLY+3/4,MFOFDLY+3/4
 
*	The following SETs are placed such that another SET to the
*	same name placed anywhere outside the XTEXT will override
*	these SET values for all code assembled within this XTEXT.
 
MFERCNT	SET	10		;ERROR RETRY COUNT
 
MFONDLY	SET	60		;MOTOR ON I/O DELAY TIME IN MILLISECONDS
MFOFDLY	SET	1000		;MOTOR OFF I/O DELAY TIME IN MILLISECONDS
 
MFMIDLE	SET	30		;BOOT/DEFAULT MOTOR ON IDLE TIME IN SECONDS
 
	IF	MFBOOT-1
 
MFSIDLE	SET	3*200-20	;BOOT SELECT IDLE TIME IN MILLISECONDS
 
	ELSE
 
MFSIDLE	SET	1*200-20	;DEFAULT SELECT IDLE TIME IN MILLISECONDS
 
	ENDIF
 
MFU0TYP	SET	0B		;DEFAULT UNIT 0 CONFIGURATION
MFU0SEK	SET	30		;DEFAULT UNIT 0 SEEK STEP TIME (MS)
 
MFU1TYP	SET	0B		;DEFAULT UNIT 1 CONFIGURATION
MFU1SEK	SET	30		;DEFAULT UNIT 1 SEEK STEP TIME (MS)
 
MFU2TYP	SET	0B		;DEFAULT UNIT 2 CONFIGURATION
MFU2SEK	SET	30		;DEFAULT UNIT 2 SEEK STEP TIME (MS)
	SPACE	3
